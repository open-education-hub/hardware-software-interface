<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-Labs/lab10">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.1.0">
<title data-rh="true">Lab 10 - The C - Assembly Interaction | Hardware Software Interface</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="http://localhost//hardware-software-interface/Labs/lab10"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Lab 10 - The C - Assembly Interaction | Hardware Software Interface"><meta data-rh="true" name="description" content="Task: Maximum Calculation in Assembly with Call from C"><meta data-rh="true" property="og:description" content="Task: Maximum Calculation in Assembly with Call from C"><link data-rh="true" rel="canonical" href="http://localhost//hardware-software-interface/Labs/lab10"><link data-rh="true" rel="alternate" href="http://localhost//hardware-software-interface/Labs/lab10" hreflang="en"><link data-rh="true" rel="alternate" href="http://localhost//hardware-software-interface/Labs/lab10" hreflang="x-default"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><link rel="stylesheet" href="/hardware-software-interface/assets/css/styles.a69a9d41.css">
<link rel="preload" href="/hardware-software-interface/assets/js/runtime~main.dfa37bb3.js" as="script">
<link rel="preload" href="/hardware-software-interface/assets/js/main.5804b916.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="theme.common.skipToMainContent"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/hardware-software-interface/"><div class="navbar__logo"><img src="/hardware-software-interface/img/logo.svg" alt="Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/hardware-software-interface/img/logo.svg" alt="Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Hardware Software Interface</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/hardware-software-interface/Labs">Labs</a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/hardware-software-interface/">Introduction</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/hardware-software-interface/Labs/">Labs</a><button aria-label="Toggle the collapsible sidebar category &#x27;Labs&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hardware-software-interface/Labs/lab1">Lab 1 - Number Representation</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hardware-software-interface/Labs/lab2">Lab 2 - Memory Operations. Introduction to GDB</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hardware-software-interface/Labs/lab4">Lab 4 - Toolchain. GOTO</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hardware-software-interface/Labs/lab5">Lab 5 - Introduction to Assembly Language</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hardware-software-interface/Labs/lab6">Lab 6 - Registers and Memory Addressing</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hardware-software-interface/Labs/lab7">Lab 7 - Structures, Vectors and Strings</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hardware-software-interface/Labs/lab8">Lab 8 - The Stack</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hardware-software-interface/Labs/lab9">Lab 9 - Functions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/hardware-software-interface/Labs/lab10">Lab 10 - The C - Assembly Interaction</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hardware-software-interface/Labs/lab11">Lab 11 - Buffer Management. Buffer Overflow</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hardware-software-interface/Labs/lab12">Lab 12 - Linking</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hardware-software-interface/Labs/lab13">Lab 13 - CTF</a></li></ul></li></ul></nav><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/hardware-software-interface/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/hardware-software-interface/Labs/"><span itemprop="name">Labs</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Lab 10 - The C - Assembly Interaction</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Lab 10 - The C - Assembly Interaction</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="task-maximum-calculation-in-assembly-with-call-from-c">Task: Maximum Calculation in Assembly with Call from C<a class="hash-link" href="#task-maximum-calculation-in-assembly-with-call-from-c" title="Direct link to heading">​</a></h2><p>Navigate to <code>drills/tasks/max-c-calls/support</code> and open <code>main.c</code></p><p>In this subdirectory you can find an implementation of calculating the maximum of a number where the <code>main()</code> function is defined in C from which the <code>get_max()</code> function defined in assembly language is called.</p><p>Trace the code in the two files and how the function arguments and return value are passed.</p><p>Compile and run the program.
To compile it run the command:</p><div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token function" style="color:#d73a49">make</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Then run the resulting executable:</p><div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-bash codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">./mainmax</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><p><strong>IMPORTANT:</strong>
Pay attention to understanding the code before proceeding to the next exercise.</p><p><strong>IMPORTANT:</strong>
The return value of a function is placed in the <code>eax</code> register.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="maximum-computation-extension-in-assembly-with-call-from-c">Maximum Computation Extension in Assembly with Call from C<a class="hash-link" href="#maximum-computation-extension-in-assembly-with-call-from-c" title="Direct link to heading">​</a></h3><p>Extend the program from the previous exercise (in assembly language and C) so that the <code>get_max()</code> function now has the signature <code>unsigned int get_max(unsigned int *arr, unsigned int len, unsigned int *pos)</code>.
The third argument to the function is the address where the position in the vector on which the maximum is found will be held.</p><p>The position in the vector on which the maximum is found will also be displayed on display.</p><blockquote><p><strong>TIP:</strong>
To hold the position, it is best to define a local variable <code>pos</code> in the <code>main()</code> function in the C file (<code>main.c</code>) in the form</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">unsigned int pos;</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>and call the <code>get_max()</code> function in the form:</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">max = get_max(arr, 10, &amp;pos);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></blockquote><p>If you&#x27;re having difficulties solving this exercise, go through <a href="/hardware-software-interface/Labs/lab10#c---assembly-interaction-stack">this relevant section</a> reading material.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="task-corrupt-stack-frame-debugging">Task: Corrupt Stack Frame Debugging<a class="hash-link" href="#task-corrupt-stack-frame-debugging" title="Direct link to heading">​</a></h2><p>Navigate to <code>drills/tasks/stack-frame/support</code> and open <code>main.c</code></p><p>In current subdirectory of the lab&#x27;s task archive you can find a C program that implements the display of the string <code>Hello world!</code> by a call to the <code>print_hello()</code> function defined in the assembly for the first part of the message, followed by two calls to the <code>printf()</code> function directly from the C code.</p><p>Compile and run the program.
What do you notice?
The printed message is not as expected because the assembly code is missing an instruction.</p><p>Use GDB to inspect the address at the top of the stack before executing the <code>ret</code> statement in the <code>print_hello()</code> function.
What does it point to?
Track the values of the <code>ebp</code> and <code>esp</code> registers during the execution of this function.
What should be at the top of the stack after execution of the <code>leave</code> statement?</p><p>Find the missing instruction and rerun the executable.</p><blockquote><p><strong>TIP:</strong>
In order to restore the stack to its state at the start of the current function, the <code>leave</code> statement relies on the function&#x27;s pointer frame having been set.</p></blockquote><p>If you&#x27;re having difficulties solving this exercise, go through <a href="/hardware-software-interface/Labs/lab10#c---assembly-interaction-stack">this relevant section</a> reading material.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="task-maximum-calculation-in-c-with-call-from-assembly">Task: Maximum Calculation in C with Call from Assembly<a class="hash-link" href="#task-maximum-calculation-in-c-with-call-from-assembly" title="Direct link to heading">​</a></h2><p>Navigate to <code>drills/tasks/max-assembly-calls/support/</code> and open <code>main.asm</code></p><p>In this directory you can find an implementation of calculating the maximum of a number where the <code>main()</code> function is defined in assembly language from which the <code>get_max()</code> function defined in C is called.</p><p>Trace the code in the two files and how the function arguments and return value are passed.</p><p>Compile and run the program.</p><blockquote><p><strong>IMPORTANT:</strong>
Pay attention to understanding the code before proceeding to the next exercise.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="extending-maximum-computation-in-c-with-call-from-assembly">Extending Maximum Computation in C with Call from Assembly<a class="hash-link" href="#extending-maximum-computation-in-c-with-call-from-assembly" title="Direct link to heading">​</a></h3><p>Extend the program from the previous exercise (in assembly language and C) so that the <code>get_max()</code> function now has the signature <code>unsigned int get_max(unsigned int *arr, unsigned int len, unsigned int *pos)</code>.
The third argument to the function is the address where the position in the vector on which the maximum is found will be held.</p><p>The position in the vector on which the maximum is found will also be displayed on display.</p><blockquote><p><strong>TIP:</strong>
To hold the position, it is best to define a global variable in the assembly file (<code>main.asm</code>) in the <code>.data</code> section, of the form</p><div class="language-Assembly codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Assembly codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">pos: dd 0</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>This variable you will pass (by address) to the <code>get_max()</code> call and by value to the <code>printf()</code> call for display.</p><p>For display modify the <code>print_format</code> string and the <code>printf()</code> call in the assembly file (<code>main.asm</code>) to allow two values to be displayed: maximum and position.</p></blockquote><p>If you&#x27;re having difficulties solving this exercise, go through <a href="/hardware-software-interface/Labs/lab10#c---assembly-interaction-stack">this relevant section</a> reading material.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="task-keeping-records">Task: Keeping Records<a class="hash-link" href="#task-keeping-records" title="Direct link to heading">​</a></h2><p>Navigate to <code>drills/tasks/regs-preserve/support</code> and open <code>main.asm</code></p><p>In this subdirectory of the lab&#x27;s task repository you will find the <code>print_reverse_array()</code> function implemented by a simple loop that makes repeated calls of the <code>printf()</code> function.</p><p>Follow the code in the <code>main.asm</code> file, compile and run the program.
What happened?
The program runs indefinitely.
This is because the <code>printf()</code> function does not preserve the value in the <code>ecx</code> register, used here as a counter.</p><p>Uncomment the lines marked <code>TODO1</code> and rerun the program.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="troubleshooting-segfault">Troubleshooting SEGFAULT<a class="hash-link" href="#troubleshooting-segfault" title="Direct link to heading">​</a></h3><p>Decompose the lines marked <code>TODO2</code> in the assembly file from the previous exercise.
The code sequence makes a call to the <code>double_array()</code> function, implemented in C, just before displaying the vector using the function seen earlier.</p><p>Compile and run the program.
To debug the segfault you can use the <code>objdump</code> utility to trace the assembly language code corresponding to the <code>double_array()</code> function.
Notice which of the registers used before and after the call are modified by this function.</p><p>Add the instructions for preserving and restoring the required registers to the assembly file.</p><p>If you&#x27;re having difficulties solving this exercise, go through <a href="/hardware-software-interface/Labs/lab10#c---assembly-interaction-memory-perspective">this relevant section</a> reading material.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="task-warning-not-an-error">Task: Warning (not an error)<a class="hash-link" href="#task-warning-not-an-error" title="Direct link to heading">​</a></h2><p>Access the directory <code>drills/tasks/include-fix/support/</code>.
Run the <code>make</code> command.
A warning appears, but it is from the preprocessing/compilation process.
Resolve this warning by editing the <code>hello.c</code> file.</p><p><strong>Bonus</strong>: Fix the warning without using the <code>#include</code> directive.</p><p>If you&#x27;re having difficulties solving this exercise, go through <a href="/hardware-software-interface/Labs/lab12#linking">this</a> reading material.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="task-fixing-export-issues">Task: Fixing Export Issues<a class="hash-link" href="#task-fixing-export-issues" title="Direct link to heading">​</a></h2><p>Access the directory <code>drills/tasks/export-fix/support/</code>.
Each subdirectory (<code>a-func/</code>, <code>b-var/</code>, <code>c-var-2/</code>) contains a problem related to the export of symbols (functions or variables).
In each subdirectory, run the <code>make</code> command, identify the issue, and edit the necessary files to resolve it.</p><p>If you&#x27;re having difficulties solving this exercise, go through <a href="/hardware-software-interface/Labs/lab12#linking">this</a> reading material.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="task-maximum-computation-in-assembly-with-64-bit-c-call">Task: Maximum Computation in Assembly with 64-bit C Call<a class="hash-link" href="#task-maximum-computation-in-assembly-with-64-bit-c-call" title="Direct link to heading">​</a></h2><p>Navigate to <code>drills/tasks/max-c-calls-x64/support</code> and open <code>main.c</code></p><p>In this subdirectory you should have implemented the maximum assembly language calculation on a 64-bit system.
Start the program from exercises 4 and 5 in such a way that you run it using a 64-bit system.</p><blockquote><p><strong>TIP:</strong>
<a href="https://en.wikipedia.org/wiki/X86_calling_conventions" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/X86_calling_conventions</a>.</p><p>The first thing to note is that on the x64 architecture the registers are 8 bytes in size and have different names than the 32-bit ones (in addition to extending the traditional ones: <code>eax</code> register becomes <code>rax</code>, <code>ebx</code> register becomes <code>rbx</code>, etc., there are new ones: R10-R15: for more information see <a href="https://stackoverflow.com/questions/20637569/assembly-registers-in-64-bit-architecture" target="_blank" rel="noopener noreferrer">here</a>).</p><p>Also, on x64 architecture parameters are no longer sent to the stack, but put in registers.
The first 3 parameters are put in: <code>rdi</code>, <code>rsi</code> and <code>rdx</code> registers.
This is not a uniformly adopted convention.
This convention is only valid on Linux, on Windows there are other registers which are used to pass the parameters of a function.
The calling convention requires that, for functions with a variable number of arguments, <code>rax</code> register be set to the number of vector registers used to pass arguments.
<code>printf()</code> is a variable argument count function, and unless you use registers other than those mentioned in the previous paragraph for passing arguments, you must set <code>rax = 0</code> before calling.
Read more <a href="https://stackoverflow.com/questions/38335212/calling-printf-in-x86-64-using-gnu-assembler" target="_blank" rel="noopener noreferrer">here</a>.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="task-bonus-maximum-calculation-in-c-with-call-from-assembly---64-bits">Task: Bonus: Maximum Calculation in C with Call from Assembly - 64 Bits<a class="hash-link" href="#task-bonus-maximum-calculation-in-c-with-call-from-assembly---64-bits" title="Direct link to heading">​</a></h2><p>Enter the directory <code>drills/tasks/max-assembly-calls-x64/support</code> and implement the maximum calculation in C with a call from Assembly language on a 64-bit system.
Start from the program used in <code>drills/tasks/max-assembly-calls</code>, ensuring it runs on a 64-bit system.
Follow the instructions from the previous exercise and pay attention to the order of parameters.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="c---assembly-interaction-memory-perspective">C - Assembly Interaction: Memory Perspective<a class="hash-link" href="#c---assembly-interaction-memory-perspective" title="Direct link to heading">​</a></h2><p>Considering that assembly language poses challenges both in reading and in developing code, the general trend is to migrate towards high-level languages (which are much easier to read and provide a more user-friendly API).
However, there are still situations where, for optimization reasons, small assembly routines are used and integrated into the high-level language module.</p><p>In this laboratory, we will explore how assembly modules can be integrated into C programs and vice versa.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="using-assembly-procedures-in-c-functions">Using Assembly Procedures in C Functions<a class="hash-link" href="#using-assembly-procedures-in-c-functions" title="Direct link to heading">​</a></h3><p>Using assembly procedures in C functions for a C program to be executed, it must be translated into the machine code of the processor;
this is the task of a compiler.
Since this compiled code is not always optimal, in some cases it is preferable to replace portions of code written in C with portions of assembly code that do the same thing, but with better performance.</p><h4 class="anchor anchorWithStickyNavbar_LWe7" id="declaration-of-the-procedure">Declaration of the Procedure<a class="hash-link" href="#declaration-of-the-procedure" title="Direct link to heading">​</a></h4><p>In order to ensure that the assembly procedure and Module C are properly combined and compatible, the following steps must be followed:</p><ul><li><p>declare the procedure label as global, using the GLOBAL directive.
In addition to this, any data that will be used by the procedure must be declared as global.</p></li><li><p>using the <code>extern</code> directive to declare procedures and global data as external.</p></li></ul><h3 class="anchor anchorWithStickyNavbar_LWe7" id="calling-c-functions-from-assembly-procedures">Calling C Functions from Assembly Procedures<a class="hash-link" href="#calling-c-functions-from-assembly-procedures" title="Direct link to heading">​</a></h3><p>In most cases, calling routines or functions from the standard C library in an assembly language program is a much more complex operation than vice versa.
Take the example of calling the <code>printf()</code> function from an assembly language program:</p><div class="language-Assembly codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Assembly codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">global main</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">external printf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">section .data</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">text db &quot;291 is the best!&quot;, 10, 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">strformat db &quot;%s&quot;, 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">section .code</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">main:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        push dword text</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        push dword strformat</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        call printf</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        add esp, 8</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ret</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Note that the procedure is declared as global and is called <code>main</code> - the starting point of any C program.
Since in C the parameters are stacked in reverse order, the string offset is set first, followed by the format string offset.
The C function can be called afterwards, but the stack must be restored when the function exits.</p><p>When linking assembly code the standard C library (or the library containing the functions you use) must be included.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="c---assembly-interaction-stack">C - Assembly Interaction: Stack<a class="hash-link" href="#c---assembly-interaction-stack" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="setting-the-stack">Setting the Stack<a class="hash-link" href="#setting-the-stack" title="Direct link to heading">​</a></h3><p>When entering a procedure, it is necessary to set a stack frame to which to send parameters.
Of course, if the procedure does not receive parameters, this step is not necessary. So to set the stack, the following code must be included:</p><div class="language-Assembly codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Assembly codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">push ebp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mov ebp, esp</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>The EBP gives us the ability to use it as an index within the stack and should not be altered during the procedure.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="passing-parameters-from-c-to-the-assembly-procedure">Passing Parameters from C to the Assembly Procedure<a class="hash-link" href="#passing-parameters-from-c-to-the-assembly-procedure" title="Direct link to heading">​</a></h3><p>C programs send parameters to assembly procedures using the stack.
Consider the following C program sequence:</p><div class="language-C codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-C codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">##include &lt;stdio.h&gt;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">extern int sum(int a, int b);  // declare the assembly procedure as external</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">int main() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int a = 5, b = 7;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    int res = sum(a, b);  // call the assembly procedure</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>When C executes the call to <code>sum()</code>, it first pushes arguments on the stack in reverse order, then actually calls the procedure.
Thus, upon entering the procedure body, the stack will be intact.</p><p>Since the variables <code>a</code> and <code>b</code> are declared as <code>int</code> values, they will each use one word on the stack.
This method of passing parameters is called value passing.
The code of the Sum procedure might look like this:</p><div class="language-Assembly codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Assembly codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">section .text</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    global sum   ; declare the procedure label as global</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sum:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    push ebp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mov ebp, esp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mov eax, [ebp+8]     ; retrieve the first argument</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    mov ecx, [ebp+12]    ; retrieve the second argument</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    add eax, ecx         ; calculate the sum</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    pop ebp</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ret</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>It is interesting to note several things.
First, the assembly code defaults the return value of the procedure to the <code>eax</code> register.
Second, the <code>ret</code> command is sufficient to exit the procedure, due to the fact that the C compiler takes care of the rest of the stuff, such as removing parameters from the stack.</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/hardware-software-interface/Labs/lab9"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Lab 9 - Functions</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/hardware-software-interface/Labs/lab11"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Lab 11 - Buffer Management. Buffer Overflow</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#task-maximum-calculation-in-assembly-with-call-from-c" class="table-of-contents__link toc-highlight">Task: Maximum Calculation in Assembly with Call from C</a><ul><li><a href="#maximum-computation-extension-in-assembly-with-call-from-c" class="table-of-contents__link toc-highlight">Maximum Computation Extension in Assembly with Call from C</a></li></ul></li><li><a href="#task-corrupt-stack-frame-debugging" class="table-of-contents__link toc-highlight">Task: Corrupt Stack Frame Debugging</a></li><li><a href="#task-maximum-calculation-in-c-with-call-from-assembly" class="table-of-contents__link toc-highlight">Task: Maximum Calculation in C with Call from Assembly</a><ul><li><a href="#extending-maximum-computation-in-c-with-call-from-assembly" class="table-of-contents__link toc-highlight">Extending Maximum Computation in C with Call from Assembly</a></li></ul></li><li><a href="#task-keeping-records" class="table-of-contents__link toc-highlight">Task: Keeping Records</a><ul><li><a href="#troubleshooting-segfault" class="table-of-contents__link toc-highlight">Troubleshooting SEGFAULT</a></li></ul></li><li><a href="#task-warning-not-an-error" class="table-of-contents__link toc-highlight">Task: Warning (not an error)</a></li><li><a href="#task-fixing-export-issues" class="table-of-contents__link toc-highlight">Task: Fixing Export Issues</a></li><li><a href="#task-maximum-computation-in-assembly-with-64-bit-c-call" class="table-of-contents__link toc-highlight">Task: Maximum Computation in Assembly with 64-bit C Call</a></li><li><a href="#task-bonus-maximum-calculation-in-c-with-call-from-assembly---64-bits" class="table-of-contents__link toc-highlight">Task: Bonus: Maximum Calculation in C with Call from Assembly - 64 Bits</a></li><li><a href="#c---assembly-interaction-memory-perspective" class="table-of-contents__link toc-highlight">C - Assembly Interaction: Memory Perspective</a><ul><li><a href="#using-assembly-procedures-in-c-functions" class="table-of-contents__link toc-highlight">Using Assembly Procedures in C Functions</a></li><li><a href="#calling-c-functions-from-assembly-procedures" class="table-of-contents__link toc-highlight">Calling C Functions from Assembly Procedures</a></li></ul></li><li><a href="#c---assembly-interaction-stack" class="table-of-contents__link toc-highlight">C - Assembly Interaction: Stack</a><ul><li><a href="#setting-the-stack" class="table-of-contents__link toc-highlight">Setting the Stack</a></li><li><a href="#passing-parameters-from-c-to-the-assembly-procedure" class="table-of-contents__link toc-highlight">Passing Parameters from C to the Assembly Procedure</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://curs.upb.ro" target="_blank" rel="noopener noreferrer" class="footer__link-item">Main site<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://ocw.cs.pub.ro/courses/pclp2" target="_blank" rel="noopener noreferrer" class="footer__link-item">OCW<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://www.facebook.com/10c1a" target="_blank" rel="noopener noreferrer" class="footer__link-item">Facebook<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 OpenEdu Team</div></div></div></footer></div>
<script src="/hardware-software-interface/assets/js/runtime~main.dfa37bb3.js"></script>
<script src="/hardware-software-interface/assets/js/main.5804b916.js"></script>
</body>
</html>