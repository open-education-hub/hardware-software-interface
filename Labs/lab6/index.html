<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-Labs/lab6">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.1.0">
<title data-rh="true">Lab 6 - Registers and Memory Addressing | Hardware Software Interface</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="http://localhost//hardware-software-interface/Labs/lab6"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Lab 6 - Registers and Memory Addressing | Hardware Software Interface"><meta data-rh="true" name="description" content="Task: Division of Two Numbers"><meta data-rh="true" property="og:description" content="Task: Division of Two Numbers"><link data-rh="true" rel="canonical" href="http://localhost//hardware-software-interface/Labs/lab6"><link data-rh="true" rel="alternate" href="http://localhost//hardware-software-interface/Labs/lab6" hreflang="en"><link data-rh="true" rel="alternate" href="http://localhost//hardware-software-interface/Labs/lab6" hreflang="x-default"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><link rel="stylesheet" href="/hardware-software-interface/assets/css/styles.a69a9d41.css">
<link rel="preload" href="/hardware-software-interface/assets/js/runtime~main.dfa37bb3.js" as="script">
<link rel="preload" href="/hardware-software-interface/assets/js/main.5804b916.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="theme.common.skipToMainContent"><a href="#" class="skipToContent_fXgn">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/hardware-software-interface/"><div class="navbar__logo"><img src="/hardware-software-interface/img/logo.svg" alt="Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/hardware-software-interface/img/logo.svg" alt="Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">Hardware Software Interface</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/hardware-software-interface/Labs">Labs</a></div><div class="navbar__items navbar__items--right"><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper mainWrapper_z2l0 docsWrapper_BCFX"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docPage__5DB"><aside class="theme-doc-sidebar-container docSidebarContainer_b6E3"><div class="sidebar_njMd"><nav class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/hardware-software-interface/">Introduction</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/hardware-software-interface/Labs/">Labs</a><button aria-label="Toggle the collapsible sidebar category &#x27;Labs&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hardware-software-interface/Labs/lab1">Lab 1 - Number Representation</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hardware-software-interface/Labs/lab2">Lab 2 - Memory Operations. Introduction to GDB</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hardware-software-interface/Labs/lab4">Lab 4 - Toolchain. GOTO</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hardware-software-interface/Labs/lab5">Lab 5 - Introduction to Assembly Language</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/hardware-software-interface/Labs/lab6">Lab 6 - Registers and Memory Addressing</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hardware-software-interface/Labs/lab7">Lab 7 - Structures, Vectors and Strings</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hardware-software-interface/Labs/lab8">Lab 8 - The Stack</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hardware-software-interface/Labs/lab9">Lab 9 - Functions</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hardware-software-interface/Labs/lab10">Lab 10 - The C - Assembly Interaction</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hardware-software-interface/Labs/lab11">Lab 11 - Buffer Management. Buffer Overflow</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hardware-software-interface/Labs/lab12">Lab 12 - Linking</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/hardware-software-interface/Labs/lab13">Lab 13 - CTF</a></li></ul></li></ul></nav><button type="button" title="Collapse sidebar" aria-label="Collapse sidebar" class="button button--secondary button--outline collapseSidebarButton_PEFL"><svg width="20" height="20" aria-hidden="true" class="collapseSidebarButtonIcon_kv0_"><g fill="#7a7a7a"><path d="M9.992 10.023c0 .2-.062.399-.172.547l-4.996 7.492a.982.982 0 01-.828.454H1c-.55 0-1-.453-1-1 0-.2.059-.403.168-.551l4.629-6.942L.168 3.078A.939.939 0 010 2.528c0-.548.45-.997 1-.997h2.996c.352 0 .649.18.828.45L9.82 9.472c.11.148.172.347.172.55zm0 0"></path><path d="M19.98 10.023c0 .2-.058.399-.168.547l-4.996 7.492a.987.987 0 01-.828.454h-3c-.547 0-.996-.453-.996-1 0-.2.059-.403.168-.551l4.625-6.942-4.625-6.945a.939.939 0 01-.168-.55 1 1 0 01.996-.997h3c.348 0 .649.18.828.45l4.996 7.492c.11.148.168.347.168.55zm0 0"></path></g></svg></button></div></aside><main class="docMainContainer_gTbr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/hardware-software-interface/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_OVgt"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/hardware-software-interface/Labs/"><span itemprop="name">Labs</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Lab 6 - Registers and Memory Addressing</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Lab 6 - Registers and Memory Addressing</h1><h2 class="anchor anchorWithStickyNavbar_LWe7" id="task-division-of-two-numbers">Task: Division of Two Numbers<a class="hash-link" href="#task-division-of-two-numbers" title="Direct link to heading">​</a></h2><p>You will solve this exercise starting from the <code>divide.asm</code> file located in the <code>drills/tasks/div/support</code> directory.</p><p>In the <code>divide.asm</code> program, the quotient and remainder of two numbers represented as bytes are calculated.
Update the area marked with <code>TODO</code> to perform divisions <code>dividend2 / divisor2</code> (word-type divisor) and <code>dividend3 / divisor3</code> (dword-type divisor).</p><p>Similar to the <code>mul</code> instruction, the registers where the dividend is placed vary depending on the representation size of the divisor.
The divisor is passed as an argument to the <code>div</code> mnemonic.</p><blockquote><p><strong>TIP</strong>: If the divisor is of type <code>byte</code> (8 bits), the components are arranged as follows:</p><ul><li>the dividend is placed in the <code>ax</code> register</li><li>the argument of the <code>div</code> instruction is 8 bits and can be represented by a register or an immediate value</li><li>the quotient is placed in <code>al</code></li><li>the remainder is placed in <code>ah</code></li></ul><p>If the divisor is of type <code>word</code> (16 bits), the components are arranged as follows:</p><ul><li>the dividend is arranged in the <code>dx:ax</code> pair, meaning its <code>high</code> part is in the <code>dx</code> register, and the <code>low</code> part is in <code>ax</code></li><li>the argument of the <code>div</code> instruction is 16 bits and can be represented by a register or an immediate value</li><li>the quotient is placed in <code>ax</code></li><li>the remainder is placed in <code>dx</code></li></ul><p>If the divisor is of type <code>dword</code> (32 bits), the components are arranged as follows:</p><ul><li>the dividend is arranged in the <code>edx:eax</code> pair, meaning its <code>high</code> part is in the <code>edx</code> register, and the <code>low</code> part is in <code>eax</code></li><li>the argument of the <code>div</code> instruction is 32 bits and can be represented by a register or an immediate value</li><li>the quotient is placed in <code>eax</code></li><li>the remainder is placed in <code>edx</code></li></ul><p><strong>TIP</strong>: If the program gives you a <code>SIGFPE</code>.
Arithmetic exception,&quot; you most likely forgot to initialize the upper part of the dividend (<code>ah</code>, <code>dx</code>, or <code>edx</code>).</p></blockquote><p>If you&#x27;re having difficulties solving this exercise, go through <a href="/hardware-software-interface/Labs/lab6#registers">this</a> reading material.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="task-multiplying-two-numbers">Task: Multiplying Two Numbers<a class="hash-link" href="#task-multiplying-two-numbers" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-multiplying-two-numbers-represented-as-bytes">1. Multiplying Two Numbers represented as Bytes<a class="hash-link" href="#1-multiplying-two-numbers-represented-as-bytes" title="Direct link to heading">​</a></h3><p>You will solve this exercise starting from the <code>multiply.asm</code> file located in the <code>drills/tasks/mul/support</code> directory.</p><p>Go through, run, and test the code from the file <code>multiply.asm</code>.
In this program, we multiply two numbers defined as bytes.
To access them, we use a construction like <code>byte [register]</code>.</p><p>When performing multiplication, the process is as follows, as described <a href="https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic" target="_blank" rel="noopener noreferrer">here</a>:</p><ol><li>We place the multiplicand in the multiplicand register, meaning:<ul><li>if we&#x27;re operating on a byte (8 bits, one byte), we place the multiplicand in the <code>al</code> register;</li><li>if we&#x27;re operating on a word (16 bits, 2 bytes), we place the multiplicand in the <code>ax</code> register;</li><li>if we&#x27;re operating on a double word (32 bits, 4 bytes), we place the multiplicand in the <code>eax</code> register.</li></ul></li><li>The multiplier is passed as an argument to the <code>mul</code> mnemonic.
The multiplier must have the same size as the multiplicand.</li><li>The result is placed in two registers (the high part and the low part).</li></ol><h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-multiplying-two-numbers-represented-as-words--double-words">2. Multiplying Two Numbers represented as Words / Double Words<a class="hash-link" href="#2-multiplying-two-numbers-represented-as-words--double-words" title="Direct link to heading">​</a></h3><p>Update the area marked with <code>TODO</code> in the file <code>multiply.asm</code> to allow multiplication of <code>word</code> and <code>dword</code> numbers, namely <code>num1_dw</code> with <code>num2_dw</code>, and <code>num1_dd</code> with <code>num2_dd</code>.</p><blockquote><p><strong>TIP</strong>: For multiplying word numbers (16 bits), the components are arranged as follows:</p><ul><li>Place the multiplicand in the <code>ax</code> register.</li><li>The argument of the <code>mul</code> instruction, the multiplier (possibly another register), is 16 bits (either a value or a register such as <code>bx</code>, <code>cx</code>, <code>dx</code>).</li><li>The result of the multiplication is arranged in the pair <code>dx:ax</code>, where the high part of the result is in the <code>dx</code> register, and the low part of the result is in the <code>ax</code> register.</li></ul><p>For multiplying <code>dword</code> numbers (32 bits), the components are arranged as follows:</p><ul><li>Place the multiplicand in the <code>eax</code> register.</li><li>The argument of the <code>mul</code> instruction, the multiplier (possibly another register), is 32 bits (either a value or a register such as <code>ebx</code>, <code>ecx</code>, <code>edx</code>).</li><li>The result of the multiplication is arranged in the pair <code>edx:eax</code>, where the high part of the result is in the <code>edx</code> register, and the low part of the result is in the <code>eax</code> register.</li></ul><p><strong>NOTE</strong>: When displaying the result, use the <code>PRINTF32</code> macro to display the two registers containing the result:</p><ul><li>Registers <code>dx</code> and <code>ax</code> for multiplying word numbers.</li><li>Registers <code>edx</code> and <code>eax</code> for multiplying dword numbers.</li></ul></blockquote><p>If you&#x27;re having difficulties solving this exercise, go through <a href="/hardware-software-interface/Labs/lab6#registers">this</a> reading material.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="task-sum-of-first-n-natural-numbers-squared">Task: Sum of first N natural numbers squared<a class="hash-link" href="#task-sum-of-first-n-natural-numbers-squared" title="Direct link to heading">​</a></h2><p>You will solve this exercise starting from the <code>sum_n.asm</code> file located in the <code>drills/tasks/sum-squared/support</code> directory.</p><p>In the <code>sum_n.asm</code> program, the sum of the first <code>num</code> natural numbers is calculated.</p><p>Follow the code, observe the constructions and registers specific to working with bytes.
Run the code.</p><blockquote><p><strong>IMPORTANT</strong>: Proceed to the next step only after you have understood very well what the code does.
It will be difficult for you to do the next exercise if you have difficulties understanding the current one.</p></blockquote><p>Start with the program <code>sum_n.asm</code> and create a program <code>sum_n_square.asm</code> that calculates the sum of squares of the first <code>num</code> natural numbers (<code>num</code> &lt;= 100).</p><blockquote><p><strong>TIP</strong>: You will use the <code>eax</code> and <code>edx</code> registers for multiplication to compute the squares (using the <code>mul</code> instruction).
Therefore, you cannot easily use the <code>eax</code> register to store the sum of squares. To retain the sum of squares, you have two options:</p><ol><li>(easier) Use the <code>ebx</code> register to store the sum of squares.</li><li>(more complex) Before performing operations on the <code>eax</code> register, save its value on the stack (using the <code>push</code> instruction), then perform the necessary operations, and finally restore the saved value (using the <code>pop</code> instruction).</li></ol><p><strong>NOTE</strong>: For verification, the sum of squares of the first 100 natural numbers is <code>338350</code>.</p></blockquote><p>If you&#x27;re having difficulties solving this exercise, go through <a href="/hardware-software-interface/Labs/lab6#registers">this</a> reading material.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="task-sum-of-elements-in-an-array">Task: Sum of Elements in an Array<a class="hash-link" href="#task-sum-of-elements-in-an-array" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="introduction">Introduction<a class="hash-link" href="#introduction" title="Direct link to heading">​</a></h3><p>You will solve this exercise starting from the <code>sum-array.asm</code> file located in the <code>drills/tasks/sum-array/support</code> directory.</p><p>In the <code>sum-array.asm</code> file the sum of elements in an array of bytes (8-bit representation) is calculated.</p><p>Follow the code, observe the constructions and registers specific for working with bytes.
Run the code.</p><blockquote><p><strong>IMPORTANT</strong>: Proceed to the next step only after thoroughly understanding what the code does.
It will be difficult for you to complete the following exercises if you have difficulty understanding the current exercise.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="sum-of-elements-in-an-array-of-types-word-and-dword">Sum of Elements in an Array of types word and dword<a class="hash-link" href="#sum-of-elements-in-an-array-of-types-word-and-dword" title="Direct link to heading">​</a></h3><p>In the <code>TODO</code> section of the <code>sum-array.asm</code> file, complete the code to calculate the sum of arrays with elements of type word (16 bits) and dword (32 bits);
namely, the <code>word_array</code> and <code>dword_array</code>.</p><blockquote><p><strong>TIP</strong>: When calculating the address of an element in an array, you will use a construction like:</p><p><code>base + size * index</code></p><p>In the construction above:</p><ul><li>base is the address of the array (i.e., <code>word_array</code> or <code>dword_array</code>)</li><li>size is the length of the array element (i.e., 2 for a word array (16 bits, 2 bytes) and 4 for a dword array (32 bits, 4 bytes))</li><li>index is the current index within the array</li></ul><p><strong>NOTE</strong>: The sum of elements in the three arrays should be:</p><ul><li><code>sum(byte_array): 575</code></li><li><code>sum(word_array): 65799</code></li><li><code>sum(dword_array): 74758117</code></li></ul></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="sum-of-squares-of-elements-in-an-array">Sum of Squares of Elements in an Array<a class="hash-link" href="#sum-of-squares-of-elements-in-an-array" title="Direct link to heading">​</a></h3><p>Starting from the program in the previous exercise, calculate the sum of squares of elements in an array.</p><blockquote><p><strong>NOTE</strong>: You can use the <code>dword_array</code> array, ensuring that the sum of squares of the contained elements can be represented in 32 bits.</p><p><strong>NOTE</strong>: If you use the construction below (array with 10 elements)</p><div class="language-Assembly codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Assembly codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">dword_array dd 1392, 12544, 7992, 6992, 7202, 27187, 28789, 17897, 12988, 17992</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>the sum of squares will be 2704560839.</p></blockquote><p>If you&#x27;re having difficulties solving this exercise, go through <a href="/hardware-software-interface/Labs/lab6#memory-addressing">this</a> reading material.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="task-count-array-elements">Task: Count Array Elements<a class="hash-link" href="#task-count-array-elements" title="Direct link to heading">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="count-negative-and-positive-numbers-from-array">Count Negative and Positive Numbers from Array<a class="hash-link" href="#count-negative-and-positive-numbers-from-array" title="Direct link to heading">​</a></h3><p>You will solve this exercise starting from the <code>count_pos_neg.asm</code> file located in the <code>drills/tasks/vec-count-if/support</code> directory.</p><p>Your program should display the number of positive and negative values from the array.</p><blockquote><p><strong>NOTE</strong>: Define a vector that contains both negative and positive numbers.</p><p><strong>TIP</strong>: Use the <code>cmp</code> instruction and conditional jump mnemonics. See details <a href="https://en.wikipedia.org/wiki/X86_instruction_listings" target="_blank" rel="noopener noreferrer">here</a>.</p><p><strong>TIP</strong>: The <code>inc</code> instruction followed by a register increments the value stored in that register.</p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="count-odd-and-even-numbers-from-array">Count Odd and Even Numbers from Array<a class="hash-link" href="#count-odd-and-even-numbers-from-array" title="Direct link to heading">​</a></h3><p>Create a new file called <code>count_even_odd.asm</code> file located in the <code>drills/tasks/vec-count-if/support</code> directory.</p><p>Your program should display the number of even and odd values from an array.</p><blockquote><p><strong>TIP</strong>: You can use the <code>div</code> instruction to divide a number by 2 and then compare the remainder of the division with 0.</p><p><strong>NOTE</strong>: For testing, use an array containing only positive numbers.</p></blockquote><p>For negative numbers, sign extension should be performed; it would work without it because we are only interested in the remainder, but let&#x27;s be rigorous :-)</p><p>If you&#x27;re having difficulties solving this exercise, go through <a href="/hardware-software-interface/Labs/lab6#memory-addressing">this</a> reading material.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="registers">Registers<a class="hash-link" href="#registers" title="Direct link to heading">​</a></h2><p>Registers are the primary &quot;tools&quot; used to write programs in assembly language.
They are like variables built into the processor.
Using registers instead of direct memory addressing makes developing and reading assembly-written programs faster and easier.
The only disadvantage of programming in x86 assembly language is that there are few registers.</p><p>Modern x86 processors have 8 general-purpose registers whose size is 32 bits.
The names of the registers are of historical nature (for example: <code>eax</code> was called the accumulator register because it is used by a series of arithmetic instructions, such as <a href="https://www.felixcloutier.com/x86/idiv" target="_blank" rel="noopener noreferrer">idiv</a>).
While most registers have lost their special purpose, becoming &quot;general purpose&quot; in the modern ISA (<code>eax</code>, <code>ebx</code>, <code>ecx</code>, <code>edx</code>, <code>esi</code>, <code>edi</code>), by convention, 2 have retained their initial purpose: <code>esp</code> (stack pointer) and <code>ebp</code> (base pointer).</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="register-subsections">Register Subsections<a class="hash-link" href="#register-subsections" title="Direct link to heading">​</a></h3><p>In certain cases, we want to manipulate values that are represented in less than 4 bytes (for example, working with character strings).
For these situations, x86 processors offer us the possibility to work with subsections of 1 and 2 bytes of the <code>eax</code>, <code>ebx</code>, <code>ecx</code>, <code>edx</code> registers.</p><p>The image below represents the registers, their subsections, and their sizes.</p><p><img loading="lazy" alt="x86_32 Registers" src="/hardware-software-interface/assets/images/registers-0db2e8e77041c8e0b8e0454074e866a8.svg" class="img_ev3q"></p><blockquote><p><strong>WARNING</strong>: Subsections are part of registers, which means that if we modify a register, we implicitly modify the value of the subsection.</p><p><strong>NOTE</strong>: Subsections are used in the same way as registers, only the size of the retained value is different.</p><p><strong>NOTE</strong>: Besides the basic registers, there are also six segment registers corresponding to certain areas as seen in the image:</p><p><img loading="lazy" alt="Segment Registers" src="/hardware-software-interface/assets/images/segments-48963525b46d75a87b71f2fbdc282e44.svg" class="img_ev3q"></p></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="static-memory-region-declarations">Static Memory Region Declarations<a class="hash-link" href="#static-memory-region-declarations" title="Direct link to heading">​</a></h3><p>Static memory declarations (analogous to declaring global variables) in the x86 world are made through special assembly directives.
These declarations are made in the data section (the <code>.data</code> region).
Names can be attached to the declared memory portions through a label to easily reference them later in the program. Follow the example below:</p><div class="language-Assembly codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Assembly codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">.DATA</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var        `db` 64    ; Declares a byte containing the value 64. Labels</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ; the memory location as &quot;var&quot;.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    var2       `db` ?     ; Declares an uninitialized byte labeled &quot;var2&quot;.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">               `db` 10    ; Declares an unlabeled byte, initialized with 10. This</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ; byte will be placed at the address (var2 + 1).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    X          `dw` ?     ; Declares an uninitialized word (2 bytes), labeled &quot;X&quot;.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Y          `dd` 3000  ; Declares a double word (4 bytes) labeled &quot;Y&quot;,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ; initialized with the value 3000.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    Z          `dd` 1,2,3 ; Declares 3 double words (each 4 bytes)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ; starting from address &quot;Z&quot; and initialized with 1, 2, and 3, respectively.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ; For example, 3 will be placed at the address (Z + 8).</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><p><strong>NOTE</strong>: DB, DW, DD are directives used to specify the size of the portion:</p><table><thead><tr><th>Directive</th><th>Role</th><th>Size</th></tr></thead><tbody><tr><td><code>db</code></td><td>Define Byte</td><td>1 bytes (8 bits)</td></tr><tr><td><code>dw</code></td><td>Define Word</td><td>2 bytes (16 bits)</td></tr><tr><td><code>dd</code></td><td>Define Double Word</td><td>4 bytes (32 bits)</td></tr></tbody></table><p><strong>NOTE</strong>: There are multiple types of memory regions as can be seen in the image below:</p><p><img loading="lazy" alt="Memory Sections" src="/hardware-software-interface/assets/images/sections-bd531a20bf90f40ab1dc04a208f1264d.jpg" width="640" height="480" class="img_ev3q"></p></blockquote><p>The last declaration in the above example represents the declaration of an array.
Unlike higher-level languages, where arrays can have multiple dimensions and their elements are accessed by indices, in assembly language, arrays are represented as a number of cells located in a contiguous area of memory.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="guide-multiply-and-divide">Guide: Multiply and Divide<a class="hash-link" href="#guide-multiply-and-divide" title="Direct link to heading">​</a></h2><p>To follow this guide, you&#x27;ll need to use the <code>multiply-divide.asm</code> file located in the <code>guides/multiply-divide/support</code> directory.</p><p>The program performs the <code>mul</code> and <code>div</code> instructions and prints out the results.</p><blockquote><p><strong>Note</strong>: For a detailed description of the instruction check out the following pages: <a href="https://www.felixcloutier.com/x86/div" target="_blank" rel="noopener noreferrer">div</a> and <a href="https://www.felixcloutier.com/x86/mul" target="_blank" rel="noopener noreferrer">mul</a></p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="guide-floating-point-exception">Guide: Floating Point Exception<a class="hash-link" href="#guide-floating-point-exception" title="Direct link to heading">​</a></h2><p>To follow this guide, you&#x27;ll need to use the <code>floating_point_exception.asm</code> file located in the <code>guides/floating-point-exception/support</code> directory.</p><p>The program tries to perform division using an <code>8 bit</code> operand, <code>bl</code>, in this case the quotient should be in the range <!-- -->[0, 255]<!-- -->.
Given that <code>ax</code> is <code>22891</code> and <code>bl</code> is <code>2</code>, the result of the division would be out of the defined range.
Thus we will see a <code>Floating point exception</code> after the division.</p><blockquote><p><strong>Note</strong>: For a detailed description of the <code>div</code> instruction check out the <a href="https://www.felixcloutier.com/x86/idiv" target="_blank" rel="noopener noreferrer">documentation</a>.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="memory-addressing">Memory Addressing<a class="hash-link" href="#memory-addressing" title="Direct link to heading">​</a></h2><p>Modern x86 processors can address up to 2^32 bytes of memory, which means memory addresses are represented on 32 bits.
To address memory, the processor uses addresses (implicitly, each label is translated into a corresponding memory address).
Besides labels, there are other forms of addressing memory:</p><div class="language-Assembly codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Assembly codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">mov eax, [0xcafebab3]         ; direct (displacement)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mov eax, [esi]                ; indirect (base)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mov eax, [ebp-8]              ; based (base + displacement)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mov eax, [ebx*4 + 0xdeadbeef] ; indexed (index * scale + displacement)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mov eax, [edx + ebx + 12]     ; based and indexed without scale (base + index + displacement)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mov eax, [edx + ebx*4 + 42]   ; based and indexed with scale (base + index * scale + displacement)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><blockquote><p><strong>WARNING</strong>: The following addressing modes are invalid:</p><div class="language-Assembly codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Assembly codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">mov eax, [ebx-ecx]     ; Registers can only be added</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mov [eax+esi+edi], ebx ; The address calculation can involve at most 2 registers</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></blockquote><h3 class="anchor anchorWithStickyNavbar_LWe7" id="size-directives">Size Directives<a class="hash-link" href="#size-directives" title="Direct link to heading">​</a></h3><p>Generally, the size of a value brought from memory can be inferred from the instruction code used.
For example, in the above addressing modes, the size of the values could be inferred from the size of the destination register, but in some cases, this is not so obvious.
Let&#x27;s consider the following instruction:</p><div class="language-Assembly codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Assembly codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">mov [ebx], 2</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>As seen, it intends to store the value 2 at the address contained in the <code>ebx</code> register.
The size of the register is 4 bytes.
The value 2 can be represented on both 1 and 4 bytes.
In this case, since both interpretations are valid, the processor needs additional information on how to treat this value.
This can be done through size directives:</p><div class="language-Assembly codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Assembly codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">mov byte [ebx], 2  ; Move the value 2 into the byte at the address contained in ebx.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mov word [ebx], 2  ; Move the entire 2 represented in 16 bits into the 2 bytes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   ; starting from the address contained in ebx.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">mov dword [ebx], 2 ; Move the entire 2 represented in 32 bits into the 4 bytes</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                   ; starting from the address contained in ebx.</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h3 class="anchor anchorWithStickyNavbar_LWe7" id="loop-instruction">Loop Instruction<a class="hash-link" href="#loop-instruction" title="Direct link to heading">​</a></h3><p>The loop instruction is used for loops with a predetermined number of iterations, loaded into the <code>ecx</code> register.
Its syntax is as follows:</p><div class="language-Assembly codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Assembly codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">mov ecx, 10 ; Initialize ecx with the number of iterations</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">label:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">; loop content</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">loop label</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>At each iteration, the <code>ecx</code> register is decremented, and if it&#x27;s not equal to 0, the execution jumps to the specified label.
There are other forms of the instruction that additionally check the <code>ZF</code> flag:</p><table><thead><tr><th>Mnemonic</th><th>Description</th></tr></thead><tbody><tr><td><code>loope/loopz label</code></td><td>Decrement <code>ecx</code>, jump to label if <code>ecx != 0</code> and <code>ZF == 1</code></td></tr><tr><td><code>loopne/loopnz label</code></td><td>Decrement <code>ecx</code>, jump to label if <code>ecx != 0</code> and <code>ZF != 1</code></td></tr></tbody></table><blockquote><p><strong>NOTE</strong>: When using jumps in an assembly language program, it&#x27;s important to consider the difference between a <code>short jump</code> (near jump) and a <code>long jump</code> (far jump).</p><table><thead><tr><th>Type and example</th><th>Size and significance</th><th>Description</th></tr></thead><tbody><tr><td>Short Jump (loop)</td><td>2 bytes (one byte for the opcode and one for the address)</td><td>The relative address of the instruction to which the jump is intended must not be more than 128 bytes away from the current instruction address.</td></tr><tr><td>Long Jump (jmp)</td><td>3 bytes (one byte for the opcode and two for the address)</td><td>The relative address of the instruction to which the jump is intended must not be more than 32768 bytes away from the current instruction address.</td></tr></tbody></table></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="guide-addressing-arrays">Guide: Addressing Arrays<a class="hash-link" href="#guide-addressing-arrays" title="Direct link to heading">​</a></h2><p>To follow this guide, you&#x27;ll need to use the <code>addressing_arrays.asm</code> file located in the <code>guides/addressing-arrays/support</code> directory.</p><p>The program increments the values of an array of 10 integers by 1 and iterates through the array before and after to show the changes.</p><blockquote><p><strong>Note:</strong> <code>ecx</code> is used as the loop counter.
Since the array contains <code>dwords</code> (4 bytes), the loop counter is multiplied by 4 to get the address of the next element in the array.</p></blockquote><h2 class="anchor anchorWithStickyNavbar_LWe7" id="guide-declarations">Guide: Declarations<a class="hash-link" href="#guide-declarations" title="Direct link to heading">​</a></h2><p>To follow this guide, you&#x27;ll need to use the <code>declarations.asm</code> file located in the <code>guides/declarations/support</code> directory.</p><p>The program declares multiple variables of different sizes in the <code>.bss</code> and <code>.data</code> sections.</p><blockquote><p><strong>Note</strong>: When defining strings, make sure to add a zero byte at the end, in order to mark the end of the string.</p><div class="language-Assembly codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-Assembly codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">decimal_point   db &quot;.&quot;,0</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div></blockquote><p>For a complete set of the pseudo-instruction check out the <code>nasm</code> <a href="https://nasm.us/doc/nasmdoc3.html" target="_blank" rel="noopener noreferrer">documentation</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="guide-loop">Guide: Loop<a class="hash-link" href="#guide-loop" title="Direct link to heading">​</a></h2><p>To follow this guide, you&#x27;ll need to use the <code>loop.asm</code> file located in the <code>guides/loop/support</code> directory.</p><p>This program illustrates how to use the <code>loop</code> instruction, as well as how to index an array of <code>dwords</code>.</p><blockquote><p><strong>Note</strong>: The <code>loop</code> instruction jumps to the given label when the <code>count</code> register is not equal to 0.
In the case of <code>x86</code> the <code>count</code> register is <code>ecx</code>.</p><p><strong>Note</strong>: For a detailed description of the <code>loop</code> instruction check out the <a href="https://www.felixcloutier.com/x86/loop:loopcc" target="_blank" rel="noopener noreferrer">documentation</a>.</p></blockquote></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/hardware-software-interface/Labs/lab5"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Lab 5 - Introduction to Assembly Language</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/hardware-software-interface/Labs/lab7"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Lab 7 - Structures, Vectors and Strings</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#task-division-of-two-numbers" class="table-of-contents__link toc-highlight">Task: Division of Two Numbers</a></li><li><a href="#task-multiplying-two-numbers" class="table-of-contents__link toc-highlight">Task: Multiplying Two Numbers</a><ul><li><a href="#1-multiplying-two-numbers-represented-as-bytes" class="table-of-contents__link toc-highlight">1. Multiplying Two Numbers represented as Bytes</a></li><li><a href="#2-multiplying-two-numbers-represented-as-words--double-words" class="table-of-contents__link toc-highlight">2. Multiplying Two Numbers represented as Words / Double Words</a></li></ul></li><li><a href="#task-sum-of-first-n-natural-numbers-squared" class="table-of-contents__link toc-highlight">Task: Sum of first N natural numbers squared</a></li><li><a href="#task-sum-of-elements-in-an-array" class="table-of-contents__link toc-highlight">Task: Sum of Elements in an Array</a><ul><li><a href="#introduction" class="table-of-contents__link toc-highlight">Introduction</a></li><li><a href="#sum-of-elements-in-an-array-of-types-word-and-dword" class="table-of-contents__link toc-highlight">Sum of Elements in an Array of types word and dword</a></li><li><a href="#sum-of-squares-of-elements-in-an-array" class="table-of-contents__link toc-highlight">Sum of Squares of Elements in an Array</a></li></ul></li><li><a href="#task-count-array-elements" class="table-of-contents__link toc-highlight">Task: Count Array Elements</a><ul><li><a href="#count-negative-and-positive-numbers-from-array" class="table-of-contents__link toc-highlight">Count Negative and Positive Numbers from Array</a></li><li><a href="#count-odd-and-even-numbers-from-array" class="table-of-contents__link toc-highlight">Count Odd and Even Numbers from Array</a></li></ul></li><li><a href="#registers" class="table-of-contents__link toc-highlight">Registers</a><ul><li><a href="#register-subsections" class="table-of-contents__link toc-highlight">Register Subsections</a></li><li><a href="#static-memory-region-declarations" class="table-of-contents__link toc-highlight">Static Memory Region Declarations</a></li></ul></li><li><a href="#guide-multiply-and-divide" class="table-of-contents__link toc-highlight">Guide: Multiply and Divide</a></li><li><a href="#guide-floating-point-exception" class="table-of-contents__link toc-highlight">Guide: Floating Point Exception</a></li><li><a href="#memory-addressing" class="table-of-contents__link toc-highlight">Memory Addressing</a><ul><li><a href="#size-directives" class="table-of-contents__link toc-highlight">Size Directives</a></li><li><a href="#loop-instruction" class="table-of-contents__link toc-highlight">Loop Instruction</a></li></ul></li><li><a href="#guide-addressing-arrays" class="table-of-contents__link toc-highlight">Guide: Addressing Arrays</a></li><li><a href="#guide-declarations" class="table-of-contents__link toc-highlight">Guide: Declarations</a></li><li><a href="#guide-loop" class="table-of-contents__link toc-highlight">Guide: Loop</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://curs.upb.ro" target="_blank" rel="noopener noreferrer" class="footer__link-item">Main site<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://ocw.cs.pub.ro/courses/pclp2" target="_blank" rel="noopener noreferrer" class="footer__link-item">OCW<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://www.facebook.com/10c1a" target="_blank" rel="noopener noreferrer" class="footer__link-item">Facebook<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 OpenEdu Team</div></div></div></footer></div>
<script src="/hardware-software-interface/assets/js/runtime~main.dfa37bb3.js"></script>
<script src="/hardware-software-interface/assets/js/main.5804b916.js"></script>
</body>
</html>