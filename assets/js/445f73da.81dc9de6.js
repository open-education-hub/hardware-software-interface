"use strict";(self.webpackChunkhardware_software_interface=self.webpackChunkhardware_software_interface||[]).push([[729],{5680:(e,a,t)=>{t.d(a,{xA:()=>u,yg:()=>c});var n=t(6540);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function o(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?o(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function l(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=n.createContext({}),p=function(e){var a=n.useContext(s),t=a;return e&&(t="function"==typeof e?e(a):i(i({},a),e)),t},u=function(e){var a=p(e.components);return n.createElement(s.Provider,{value:a},e.children)},d="mdxType",f={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},g=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=p(t),g=r,c=d["".concat(s,".").concat(g)]||d[g]||f[g]||o;return t?n.createElement(c,i(i({ref:a},u),{},{components:t})):n.createElement(c,i({ref:a},u))}));function c(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=g;var l={};for(var s in a)hasOwnProperty.call(a,s)&&(l[s]=a[s]);l.originalType=e,l[d]="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=t[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,t)}g.displayName="MDXCreateElement"},4398:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>s,contentTitle:()=>i,default:()=>f,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var n=t(8168),r=(t(6540),t(5680));const o={},i="Lab 11 - Buffer Management. Buffer Overflow",l={unversionedId:"Labs/lab11",id:"Labs/lab11",title:"Lab 11 - Buffer Management. Buffer Overflow",description:"Task: Buffer in the .data Section",source:"@site/docs/Labs/lab11.md",sourceDirName:"Labs",slug:"/Labs/lab11",permalink:"/hardware-software-interface/Labs/lab11",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Lab 10 - The C - Assembly Interaction",permalink:"/hardware-software-interface/Labs/lab10"},next:{title:"Lab 12 - Linking",permalink:"/hardware-software-interface/Labs/lab12"}},s={},p=[{value:"Task: Buffer in the <code>.data</code> Section",id:"task-buffer-in-the-data-section",level:2},{value:"Task: Buffer on the Stack",id:"task-buffer-on-the-stack",level:2},{value:"Part 1",id:"part-1",level:3},{value:"Part 2",id:"part-2",level:3},{value:"Part 3",id:"part-3",level:3},{value:"Task: Reading Data from Standard Input",id:"task-reading-data-from-standard-input",level:2},{value:"Buffer Overflow with Data from Standard Input",id:"buffer-overflow-with-data-from-standard-input",level:3},{value:"Task: Buffer Overflow with Data from Standard Input and <code>fgets()</code>",id:"task-buffer-overflow-with-data-from-standard-input-and-fgets",level:2},{value:"Task: Buffer Overflow for Program Written in C",id:"task-buffer-overflow-for-program-written-in-c",level:2},{value:"Overwrite Variable Using a Buffer",id:"overwrite-variable-using-a-buffer",level:3},{value:"BONUS: Stack Canary",id:"bonus-stack-canary",level:3},{value:"Task: Overwrite Return Address",id:"task-overwrite-return-address",level:2},{value:"Task: Buffer Overflow for Binary",id:"task-buffer-overflow-for-binary",level:2},{value:"Resources",id:"resources",level:3},{value:"Introduction to Buffers",id:"introduction-to-buffers",level:2},{value:"Objectives",id:"objectives",level:3},{value:"Buffer. Buffer Overflow",id:"buffer-buffer-overflow",level:3},{value:"What is a Buffer?",id:"what-is-a-buffer",level:4},{value:"What is a Buffer Overflow?",id:"what-is-a-buffer-overflow",level:4},{value:"How to make a Buffer Overflow?",id:"how-to-make-a-buffer-overflow",level:4},{value:"Infrastructure Preparation",id:"infrastructure-preparation",level:4},{value:"Buffer Overflow Attacks",id:"buffer-overflow-attacks",level:2},{value:"How is Buffer Overflow Used?",id:"how-is-buffer-overflow-used",level:3},{value:"How Do We Protect Against Buffer Overflow Attacks?",id:"how-do-we-protect-against-buffer-overflow-attacks",level:3}],u={toc:p},d="wrapper";function f(e){let{components:a,...t}=e;return(0,r.yg)(d,(0,n.A)({},u,t,{components:a,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"lab-11---buffer-management-buffer-overflow"},"Lab 11 - Buffer Management. Buffer Overflow"),(0,r.yg)("h2",{id:"task-buffer-in-the-data-section"},"Task: Buffer in the ",(0,r.yg)("inlineCode",{parentName:"h2"},".data")," Section"),(0,r.yg)("p",null,"Navigate to the ",(0,r.yg)("inlineCode",{parentName:"p"},"drills/tasks/data-buffer/support/")," directory in the laboratory's resource archive and open the ",(0,r.yg)("inlineCode",{parentName:"p"},"data_buffer.asm")," file.\nThis file contains a program that populates a buffer with information and then displays it."),(0,r.yg)("p",null,"Carefully review the program, then compile it using the command:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"make\n")),(0,r.yg)("p",null,"Notice that after running the above compilation command, both an object file and an executable file are generated. You can verify this by running the command:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-Bash"},"ls\n")),(0,r.yg)("p",null,"Run the program using the executable file, using the command:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-Bash"},"./data_buffer\n")),(0,r.yg)("p",null,"Observe the behavior of the program based on its code."),(0,r.yg)("h2",{id:"task-buffer-on-the-stack"},"Task: Buffer on the Stack"),(0,r.yg)("p",null,"Access the ",(0,r.yg)("inlineCode",{parentName:"p"},"drills/tasks/stack-buffer/support/")," directory from the lab resource archive and consult the ",(0,r.yg)("inlineCode",{parentName:"p"},"stack_buffer.asm")," file.\nThis file contains a program that populates a buffer with information and then displays it.\nIt is similar to the one above, but now the buffer is allocated on the stack."),(0,r.yg)("p",null,"The task will contain 3 parts."),(0,r.yg)("h3",{id:"part-1"},"Part 1"),(0,r.yg)("p",null,"Carefully review the program, then compile it using the command:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-Bash"},"make\n")),(0,r.yg)("p",null,"then run it using the command:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-Bash"},"./stack_buffer\n")),(0,r.yg)("p",null,"Observe the behavior of the program according to its code."),(0,r.yg)("p",null,"In addition to the buffer, we have also allocated a local variable of 4 bytes, accessible at the address ",(0,r.yg)("inlineCode",{parentName:"p"},"ebp - 4"),".\nIt is initialized to the value ",(0,r.yg)("inlineCode",{parentName:"p"},"0xCAFEBABE"),".\nThis variable will be important later on.\nWhat is relevant now is to know that this variable is in memory ",(0,r.yg)("strong",{parentName:"p"},"immediately after the buffer"),": when the buffer limit is exceeded, you reach this variable."),(0,r.yg)("p",null,"What is the difference between the two programs inspected so far?"),(0,r.yg)("h3",{id:"part-2"},"Part 2"),(0,r.yg)("p",null,"Now that we have seen what the buffer looks like in memory and where the variable is placed,\nupdate the ",(0,r.yg)("inlineCode",{parentName:"p"},"stack_buffer.asm")," program so that the buffer display sequence\n(Look for ",(0,r.yg)("strong",{parentName:"p"},"TODO 1"),") also leads to the display of the variable's bytes.\nIt is a case of read buffer overflow, with the objective of ",(0,r.yg)("strong",{parentName:"p"},"information leak"),": finding out information from memory."),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("strong",{parentName:"p"},"HINT"),' It\'s not complicated, you just need to "instruct" the display sequence to use a different limit for display,\nnot the current limit of 64 bytes.')),(0,r.yg)("p",null,"Follow ",(0,r.yg)("strong",{parentName:"p"},"TODO 2")," and display other information beyond the local variable.\nWhat information comes on the stack after the local variable (the next 4 bytes)?\nAnd the next 4 bytes after?"),(0,r.yg)("h3",{id:"part-3"},"Part 3"),(0,r.yg)("p",null,"Based on the experience above, make changes so that the variable's value is ",(0,r.yg)("inlineCode",{parentName:"p"},"0xDEADBEEF"),"\n(instead of ",(0,r.yg)("inlineCode",{parentName:"p"},"0xCAFEBABE")," as it is initially) without, however, explicitly modifying the variable's value.\nLook for ",(0,r.yg)("strong",{parentName:"p"},"TODO 3")," and use the buffer modification and the ",(0,r.yg)("inlineCode",{parentName:"p"},"ebx")," register in which we stored the start address of the buffer."),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("strong",{parentName:"p"},"TIP")," Again, it's not complicated.\nYou need to use the ",(0,r.yg)("inlineCode",{parentName:"p"},"ebx")," value and an offset to write the ",(0,r.yg)("inlineCode",{parentName:"p"},"0xDEADBEEF")," value at that address.\nThat is, use a construction like:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-Assembly"},"mov byte [ebx + TODO], TODO\n")),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},"Do this after the buffer initialization sequence (after the ",(0,r.yg)("inlineCode",{parentName:"p"},"jl fill_byte")," instruction).")),(0,r.yg)("p",null,"With a correct solution to this exercise, the program will display the ",(0,r.yg)("inlineCode",{parentName:"p"},"0xDEADBEEF")," value for the local variable."),(0,r.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,r.yg)("a",{parentName:"p",href:"/hardware-software-interface/Labs/lab11#introduction-to-buffers"},"this")," reading material."),(0,r.yg)("h2",{id:"task-reading-data-from-standard-input"},"Task: Reading Data from Standard Input"),(0,r.yg)("p",null,"Access the ",(0,r.yg)("inlineCode",{parentName:"p"},"drills/tasks/read-stdin-gets/support/")," directory from the lab resource archive and consult the ",(0,r.yg)("inlineCode",{parentName:"p"},"read_stdin.asm")," file.\nIn this file, there is a program that uses the ",(0,r.yg)("inlineCode",{parentName:"p"},"gets")," call to read information from standard input into a buffer on the stack.\nAs in the previous case, we have allocated a local variable of 4 bytes immediately after the stack buffer."),(0,r.yg)("p",null,"Carefully review the program, then compile it using the command:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-Bash"},"make\n")),(0,r.yg)("p",null,"then run it using the command:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-Bash"},"./read_stdin\n")),(0,r.yg)("p",null,"Observe the behavior of the program depending on the received input."),(0,r.yg)("h3",{id:"buffer-overflow-with-data-from-standard-input"},"Buffer Overflow with Data from Standard Input"),(0,r.yg)("p",null,"The ",(0,r.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man3/gets.3.html"},"gets")," function is practically prohibited in C programs because of its high vulnerability:\nit does not check the limits of the buffer where the reading is done, and can easily be used for buffer overflow."),(0,r.yg)("p",null,"For this, transmit the corresponding input string so that the displayed value for the local variable is not ",(0,r.yg)("inlineCode",{parentName:"p"},"0xCAFEBABE"),", but ",(0,r.yg)("inlineCode",{parentName:"p"},"0x574F4C46")," (the ASCII hexadecimal values for ",(0,r.yg)("inlineCode",{parentName:"p"},"FLOW"),")."),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("strong",{parentName:"p"},"IMPORTANT")," Do not modify the assembly language code.\nTransmit the input string in the appropriate format to the standard input to generate a buffer overflow and to obtain the required result.\n",(0,r.yg)("strong",{parentName:"p"},"WARNING")," Do not write the string ",(0,r.yg)("inlineCode",{parentName:"p"},'"574F4C46"'),".\nThis is a string that occupies ",(0,r.yg)("inlineCode",{parentName:"p"},"8")," bytes.\nYou must write the ASCII representation of the number ",(0,r.yg)("inlineCode",{parentName:"p"},"0x574F4C46"),", which is ",(0,r.yg)("inlineCode",{parentName:"p"},"FLOW"),":\n",(0,r.yg)("inlineCode",{parentName:"p"},"0x57")," is ",(0,r.yg)("inlineCode",{parentName:"p"},"W"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"0x4F")," is ",(0,r.yg)("inlineCode",{parentName:"p"},"O"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"0x4C")," is ",(0,r.yg)("inlineCode",{parentName:"p"},"L"),", and ",(0,r.yg)("inlineCode",{parentName:"p"},"0x46")," is ",(0,r.yg)("inlineCode",{parentName:"p"},"F"),".\n",(0,r.yg)("strong",{parentName:"p"},"HINT")," x86 is a ",(0,r.yg)("strong",{parentName:"p"},"little endian")," architecture.\nThat means the string ",(0,r.yg)("inlineCode",{parentName:"p"},'"FLOW"'),", having the character-ASCII code correspondence. If it seems unclear, check out this ",(0,r.yg)("a",{parentName:"p",href:"https://www.geeksforgeeks.org/little-and-big-endian-mystery/"},"link"),"\n",(0,r.yg)("inlineCode",{parentName:"p"},"F"),": ",(0,r.yg)("inlineCode",{parentName:"p"},"0x46"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"L"),": ",(0,r.yg)("inlineCode",{parentName:"p"},"0x4C"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"O"),": ",(0,r.yg)("inlineCode",{parentName:"p"},"0x4F"),", ",(0,r.yg)("inlineCode",{parentName:"p"},"W"),": ",(0,r.yg)("inlineCode",{parentName:"p"},"0x57")," will be stored in memory on ",(0,r.yg)("inlineCode",{parentName:"p"},"4")," bytes as ",(0,r.yg)("inlineCode",{parentName:"p"},"0x574F4C46"),".\nSo at the bigger address we will have ",(0,r.yg)("inlineCode",{parentName:"p"},"W"),", while at the lower address there will be ",(0,r.yg)("inlineCode",{parentName:"p"},"F"),".\n",(0,r.yg)("strong",{parentName:"p"},"HINT")," To transmit the input string, it is recommended to write it in a file and then redirect that file to the corresponding program command.\nYou can use an editor such as ",(0,r.yg)("inlineCode",{parentName:"p"},"gedit")," or ",(0,r.yg)("inlineCode",{parentName:"p"},"vim")," to edit the file.\nThe advantage is that they also display the column you are on, and you can know how many characters you have written in the file.\nAlternatively, you can use python to more easily generate your payload.\nFor example, to generate a payload that overwrites a value in the code with the value ",(0,r.yg)("inlineCode",{parentName:"p"},"0xDEADBEEF"),", you can execute the following command:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-python"},'python2.7 -c \'print "A" * 32 + "\\xEF\\xBE\\xAD\\xDE"\' > payload\n')),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("strong",{parentName:"p"},"NOTE")," number ",(0,r.yg)("inlineCode",{parentName:"p"},"32")," is only an example and it represents the size of buffer that needs to be bypassed.\nIt is recommended to name the file ",(0,r.yg)("inlineCode",{parentName:"p"},"payload"),". Redirecting the ",(0,r.yg)("inlineCode",{parentName:"p"},"payload")," file to the program is done using a command like:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-Bash"},"./read_stdin < payload\n")),(0,r.yg)("p",null,"If done correctly, you will see:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-Bash"},"var is 0x574F4C46\n")),(0,r.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,r.yg)("a",{parentName:"p",href:"/hardware-software-interface/Labs/lab11#introduction-to-buffers"},"this")," reading material."),(0,r.yg)("h2",{id:"task-buffer-overflow-with-data-from-standard-input-and-fgets"},"Task: Buffer Overflow with Data from Standard Input and ",(0,r.yg)("inlineCode",{parentName:"h2"},"fgets()")),(0,r.yg)("p",null,"As mentioned in the ",(0,r.yg)("a",{parentName:"p",href:"/hardware-software-interface/Labs/lab11#task-reading-data-from-standard-input"},(0,r.yg)("strong",{parentName:"a"},"Read Using gets")," task"),", the ",(0,r.yg)("inlineCode",{parentName:"p"},"gets()")," function is prohibited in current programs.\nInstead, the ",(0,r.yg)("inlineCode",{parentName:"p"},"fgets()")," function can be used.\nOpen the source code file ",(0,r.yg)("inlineCode",{parentName:"p"},"read_stdin_fgets.asm")," from the ",(0,r.yg)("inlineCode",{parentName:"p"},"drills/tasks/read-stdin-fgets/support/"),".\nIn the ",(0,r.yg)("inlineCode",{parentName:"p"},"read_stdin_fgets.asm")," source file, follow ",(0,r.yg)("strong",{parentName:"p"},"TODO 1")," and change the ",(0,r.yg)("inlineCode",{parentName:"p"},"gets()")," function call to the ",(0,r.yg)("inlineCode",{parentName:"p"},"fgets()")," function call."),(0,r.yg)("p",null,"For the ",(0,r.yg)("inlineCode",{parentName:"p"},"fgets()")," call, read from standard input.\nAs an argument for the third parameter of ",(0,r.yg)("inlineCode",{parentName:"p"},"fgets()")," (of type ",(0,r.yg)("inlineCode",{parentName:"p"},"FILE *"),") you will use standard input.\nTo specify standard input, use the ",(0,r.yg)("inlineCode",{parentName:"p"},"stdin")," stream.\nYou will need to mark it as external using, at the beginning of the assembly language file, the construction:"),(0,r.yg)("blockquote",null,(0,r.yg)("pre",{parentName:"blockquote"},(0,r.yg)("code",{parentName:"pre",className:"language-Assembly"},"extern stdin\n"))),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"stdin")," is an address; to call ",(0,r.yg)("inlineCode",{parentName:"p"},"fgets()")," with standard input,\nit is sufficient to pass on the stack the value from the ",(0,r.yg)("inlineCode",{parentName:"p"},"stdin")," address, i.e., using the construction:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-Assembly"},"push dword [stdin]\n")),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("strong",{parentName:"p"},"HINT")," Follow the manual page of the ",(0,r.yg)("a",{parentName:"p",href:"https://man7.org/linux/man-pages/man3/fgets.3.html"},(0,r.yg)("inlineCode",{parentName:"a"},"fgets()"))," function to find out what parameters it receives.\n",(0,r.yg)("strong",{parentName:"p"},"TIP")," Since the ",(0,r.yg)("inlineCode",{parentName:"p"},"fgets()")," function has 3 parameters (which occupy ",(0,r.yg)("inlineCode",{parentName:"p"},"3 \xd7 4 = 12")," bytes) you will need to use ",(0,r.yg)("inlineCode",{parentName:"p"},"add esp, 12")," after the function call,\nin restoring the stack, instead of ",(0,r.yg)("inlineCode",{parentName:"p"},"add esp, 4")," as in the case of the program above that used ",(0,r.yg)("inlineCode",{parentName:"p"},"gets()"),".\n",(0,r.yg)("strong",{parentName:"p"},"IMPORTANT")," Do not modify the assembly language code. Transmit the input string in the appropriate format to the standard input\nto generate a buffer overflow and to obtain the required result.")),(0,r.yg)("p",null,"Follow ",(0,r.yg)("strong",{parentName:"p"},"TODO 2")," in code and call ",(0,r.yg)("em",{parentName:"p"},"fgets()")," instead of gets, but keep in mind that you will have to push a value big enough for the buffer size in order to produce an overflow.\nThe result should be the same like in the ",(0,r.yg)("em",{parentName:"p"},"read_stdin_gets")," task."),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("strong",{parentName:"p"},"TIP")," As above, to transmit the input string for the program, it is recommended to write it in a file\nand then redirect that file to the corresponding program command.\nRedirecting the ",(0,r.yg)("inlineCode",{parentName:"p"},"payload")," file to the program is done using a command like:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-Bash"},"./read_stdin_fgets < payload\n")),(0,r.yg)("p",null,"What happens if you push ",(0,r.yg)("em",{parentName:"p"},"buffer_length - 1"),", instead of ",(0,r.yg)("em",{parentName:"p"},"buffer_length"),".\nWhy ",(0,r.yg)("em",{parentName:"p"},"var is 0x004F4C46")," now?"),(0,r.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,r.yg)("a",{parentName:"p",href:"/hardware-software-interface/Labs/lab11#introduction-to-buffers"},"this")," reading material."),(0,r.yg)("h2",{id:"task-buffer-overflow-for-program-written-in-c"},"Task: Buffer Overflow for Program Written in C"),(0,r.yg)("p",null,"Most often, we will identify buffer overflow vulnerabilities in programs written in C.\nThere we need to see what buffers are and what is the distance from the buffer to the desired variable to be able to overwrite it."),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("strong",{parentName:"p"},"IMPORTANT"),' It is important to consider that the distance between a buffer and another variable in C may not correspond to the "real-world" distance;\nthe compiler can make updates, reorders, may leave free spaces between variables, etc.')),(0,r.yg)("h3",{id:"overwrite-variable-using-a-buffer"},"Overwrite Variable Using a Buffer"),(0,r.yg)("p",null,"For the current exercise, access the ",(0,r.yg)("inlineCode",{parentName:"p"},"drills/tasks/overflow-in-c/support/")," directory from the lab resource archive and observe the corresponding C source code.\nFor the case where you do not want to compile the code yourself, you have in the archive the equivalent assembly language file and the executable file."),(0,r.yg)("p",null,"Discover the difference between the buffer's address and the variable's address, create an input file (also called ",(0,r.yg)("inlineCode",{parentName:"p"},"payload"),") with which to trigger the overflow and make it so that the message ",(0,r.yg)("em",{parentName:"p"},"Full of win")," is displayed."),(0,r.yg)("p",null,"It is recommended to first take a look at the assembly file, then understand the offsets."),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("strong",{parentName:"p"},"HINT"),' To see the "real-world" reality, i.e., to find out what the difference is between the buffer and the variable we want to overwrite,\nconsult the equivalent assembly language file (',(0,r.yg)("inlineCode",{parentName:"p"},"do_overflow.asm"),"), obtained by assembling the C code.\nIn this file, you can find the relative address of the buffer to ",(0,r.yg)("inlineCode",{parentName:"p"},"ebp")," and the variable to ",(0,r.yg)("inlineCode",{parentName:"p"},"ebp"),";\nfollow the sequence between lines ",(0,r.yg)("inlineCode",{parentName:"p"},"36")," and ",(0,r.yg)("inlineCode",{parentName:"p"},"47"),";\nyou have a mapping between the variable name and the relative offset to ",(0,r.yg)("inlineCode",{parentName:"p"},"ebp"),".\nWith this information, you can create the string to transmit as a payload to the standard input of the program.\n",(0,r.yg)("strong",{parentName:"p"},"NOTE")," If you want to recompile the files run:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-Bash"},"make clean && make\n")),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("strong",{parentName:"p"},"HINT")," As above, to transmit the input string for the program, it is recommended to write it in a file\nand then redirect that file to the corresponding program command.\nRedirecting the payload file to the program is done using a command like:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-Bash"},"./do_overflow < payload\n")),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("strong",{parentName:"p"},"HINT")," If you are confused about the value in the C code:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-C"},"if (sexy_var == 0x5541494D)\n")),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},"You can use this ",(0,r.yg)("a",{parentName:"p",href:"https://www.rapidtables.com/convert/number/hex-to-ascii.html"},"site")," to convert from hexadecimal to ASCII.")),(0,r.yg)("h3",{id:"bonus-stack-canary"},"BONUS: Stack Canary"),(0,r.yg)("p",null,"Now that you displayed ",(0,r.yg)("em",{parentName:"p"},"Full of win!"),", let's take a look at the Makefile"),(0,r.yg)("blockquote",null,(0,r.yg)("pre",{parentName:"blockquote"},(0,r.yg)("code",{parentName:"pre",className:"language-Bash"},"cat Makefile\n"))),(0,r.yg)("p",null,"Carefully analyze the compilation options.\nWhat do you notice?"),(0,r.yg)("p",null,"As observed above, despite exceeding the buffer size and overwriting another variable in the program, it terminated normally.\nThis is undesirable when working with buffers because they are a potential source of easy attacks.\nUse ",(0,r.yg)("inlineCode",{parentName:"p"},"objdump")," to inspect the ",(0,r.yg)("inlineCode",{parentName:"p"},"main")," function of the executable."),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("strong",{parentName:"p"},"HINT")," To inspect the source, use the following command:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-Bash"},"objdump -M intel -d do_overflow\n")),(0,r.yg)("p",null,"Now, go into the ",(0,r.yg)("inlineCode",{parentName:"p"},"Makefile")," and modify the ",(0,r.yg)("inlineCode",{parentName:"p"},"CFLAGS")," parameters by replacing ",(0,r.yg)("inlineCode",{parentName:"p"},"-fno-stack-protector")," with ",(0,r.yg)("inlineCode",{parentName:"p"},"-fstack-protector"),".\nRecompile the program and run it.\nWhat do you observe?"),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("strong",{parentName:"p"},"NOTE")," With the ",(0,r.yg)("inlineCode",{parentName:"p"},"-fstack-protector")," option or flag, we instructed the compiler to enable ",(0,r.yg)("em",{parentName:"p"},"Stack Smashing Protection")," for our executable.\nTherefore, any buffer overflow attack will be detected in the code, and the program execution will terminate with an error.")),(0,r.yg)("p",null,"Inspect the recompiled executable again with the new flag using ",(0,r.yg)("inlineCode",{parentName:"p"},"objdump"),".\nWhat has changed?"),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("strong",{parentName:"p"},"NOTE")," The compiler introduced a randomly generated value called a ",(0,r.yg)("strong",{parentName:"p"},"canary")," onto the stack, which it checks before exiting the current function's execution.\nThrough buffer overflow, this canary was overwritten upon exceeding the buffer's size, resulting in a mismatch between the initial canary value and the one at the end of the function execution.")),(0,r.yg)("p",null,"Recompile the files and run:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-Bash"},"make clean && make\n")),(0,r.yg)("p",null,"If you try the same payload, it will not work because of the ",(0,r.yg)("strong",{parentName:"p"},"canary")," generated. You will most likely see a message like this:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-Bash"},"Not quite there. Try again!\n*** stack smashing detected ***: terminated\nAborted (core dumped)\n")),(0,r.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,r.yg)("a",{parentName:"p",href:"/hardware-software-interface/Labs/lab11#buffer-overflow-attacks"},"this")," reading material."),(0,r.yg)("h2",{id:"task-overwrite-return-address"},"Task: Overwrite Return Address"),(0,r.yg)("p",null,"In the previous exercise, we observed how values of variables stored on the stack can be overwritten.\nRecalling how function calls are made ",(0,r.yg)("strong",{parentName:"p"},"Laboratory 9"),", the return address from a function ",(0,r.yg)("inlineCode",{parentName:"p"},"callee")," back to the ",(0,r.yg)("inlineCode",{parentName:"p"},"caller")," function is also saved on the stack."),(0,r.yg)("p",null,"Exploiting this behavior and starting from the resources in the ",(0,r.yg)("inlineCode",{parentName:"p"},"drills/tasks/overwrite-ret-addr/support/")," directory, use a buffer overflow to call the ",(0,r.yg)("inlineCode",{parentName:"p"},"void magic_function()")," by overwriting the return address in the ",(0,r.yg)("inlineCode",{parentName:"p"},"read_buffer()")," function."),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("strong",{parentName:"p"},"IMPORTANT")," The ",(0,r.yg)("inlineCode",{parentName:"p"},"void magic_function()")," calls the ",(0,r.yg)("inlineCode",{parentName:"p"},"cowsay")," utility, which you need to install with the following command:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-Bash"},"sudo apt install cowsay\n")),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("strong",{parentName:"p"},"HINT")," To inspect the source, use the following command:")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-Bash"},"objdump -M intel -d break_this\n")),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("strong",{parentName:"p"},"HINT")," In the ",(0,r.yg)("inlineCode",{parentName:"p"},"read_buffer()")," function, both the size of the input string and the string itself are read from the keyboard.\nAlthough the buffer is defined as ",(0,r.yg)("inlineCode",{parentName:"p"},"char buffer[64]"),", using the value ",(0,r.yg)("inlineCode",{parentName:"p"},"n")," in the ",(0,r.yg)("inlineCode",{parentName:"p"},"fgets(buffer, n, stdin)")," call allows for a buffer overflow.\nAlso, ",(0,r.yg)("inlineCode",{parentName:"p"},"fgets()")," will read a maximum of ",(0,r.yg)("inlineCode",{parentName:"p"},"n - 1")," characters;\n",(0,r.yg)("inlineCode",{parentName:"p"},"n")," can be set to a value larger than the actual length of the input string.")),(0,r.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,r.yg)("a",{parentName:"p",href:"/hardware-software-interface/Labs/lab11#buffer-overflow-attacks"},"this")," reading material."),(0,r.yg)("h2",{id:"task-buffer-overflow-for-binary"},"Task: Buffer Overflow for Binary"),(0,r.yg)("p",null,"Often, we don't have access to source code and want to discover vulnerabilities in executable files.\nIn the ",(0,r.yg)("inlineCode",{parentName:"p"},"drills/tasks/overflow-for-binary/support/")," directory of the laboratory resource archive, you will find an executable file.\nUsing ",(0,r.yg)("inlineCode",{parentName:"p"},"ghidra")," or ",(0,r.yg)("inlineCode",{parentName:"p"},"gdb")," for investigation, discover how to exploit the buffer overflow vulnerability to make the program display the message ",(0,r.yg)("strong",{parentName:"p"},"Great success"),"."),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("strong",{parentName:"p"},"IMPORTANT")," To run ",(0,r.yg)("inlineCode",{parentName:"p"},"ghidra")," on the ",(0,r.yg)("inlineCode",{parentName:"p"},"overflow_in_binary")," executable file, you need to create a new project and import the executable file.\nGhidra will automatically detect the file format.\nRun the analysis of the executable, then search in the Symbol Tree for the ",(0,r.yg)("inlineCode",{parentName:"p"},"main")," function.\n",(0,r.yg)("strong",{parentName:"p"},"HINT")," Identify in the disassembled code how input is passed to the program.\nIdentify where the buffer overflow occurs.\nIdentify the comparison condition you want to trigger.\nThen build the corresponding payload and deliver it in the appropriate format to the program.")),(0,r.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,r.yg)("a",{parentName:"p",href:"/hardware-software-interface/Labs/lab11#buffer-overflow-attacks"},"this")," reading material."),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("strong",{parentName:"p"},"WARNING")," If you try using a payload generated with python and it doesn't work, try simply copying its content in the terminal")),(0,r.yg)("h3",{id:"resources"},"Resources"),(0,r.yg)("p",null,"If you found the laboratory interesting in a positive way, you can learn more about this type of attack, as well as cybersecurity in general, on this ",(0,r.yg)("a",{parentName:"p",href:"https://www.youtube.com/c/LiveOverflow"},"channel"),"."),(0,r.yg)("h2",{id:"introduction-to-buffers"},"Introduction to Buffers"),(0,r.yg)("p",null,"This laboratory aims to present the concept of buffers in C and assembly language along with their specific operations, as well as the vulnerabilities they pose and how they can be exploited by a potential attacker using a program to attack a system or obtain information to which they would not normally have access."),(0,r.yg)("h3",{id:"objectives"},"Objectives"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},"Introducing the concepts of buffers and buffer overflow"),(0,r.yg)("li",{parentName:"ul"},"Examples of buffer overflow attacks"),(0,r.yg)("li",{parentName:"ul"},"Presentation of ways to secure programs to prevent buffer overflow attacks")),(0,r.yg)("h3",{id:"buffer-buffer-overflow"},"Buffer. Buffer Overflow"),(0,r.yg)("h4",{id:"what-is-a-buffer"},"What is a Buffer?"),(0,r.yg)("p",null,"A buffer is a memory area defined by a start address and a size.\nLet N be the size of the buffer, for example, the number of elements.\nThe total size of the buffer is N times the size of one element.\nA string is a specific case of a buffer."),(0,r.yg)("h4",{id:"what-is-a-buffer-overflow"},"What is a Buffer Overflow?"),(0,r.yg)("p",null,"A buffer overflow occurs when the upper limit of a buffer is exceeded during traversal, for example, the position of the last element (v","[N - 1]",").\nA buffer overflow is a specific case of an ",(0,r.yg)("em",{parentName:"p"},"index out of bounds"),", where the vector can be accessed using negative indices.\nMany functions in C do not check the size of the buffers they work with, leading to buffer overflow errors when called.\nSome examples of such functions are:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"http://www.cplusplus.com/reference/cstring/memcpy/"},"memcpy")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"https://www.cplusplus.com/reference/cstring/strcpy/"},"strcpy")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("a",{parentName:"li",href:"http://www.cplusplus.com/reference/cstdio/fgets/"},"fgets"))),(0,r.yg)("p",null,"A classic example of a buffer overflow is shown in the following code:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-C"},"char buffer[32];\nfgets(buffer, 64, stdin);\n")),(0,r.yg)("p",null,"Executing this code will result in a buffer overflow, potentially leading to a ",(0,r.yg)("em",{parentName:"p"},"Segmentation Fault")," error, although this is not guaranteed.\nEverything depends on the buffer's position in the stack and what will be overwritten by the 32 bytes that exceed the buffer's size.\nMore details on what will be overwritten and how this will be done will be discovered when solving the proposed exercises."),(0,r.yg)("h4",{id:"how-to-make-a-buffer-overflow"},"How to make a Buffer Overflow?"),(0,r.yg)("p",null,'In the previous example we see that we can use a buffer to write more than "we should".\nBut what exactly can we do with this?\nIn the following example we can use ',(0,r.yg)("em",{parentName:"p"},"fgets()")," to overwrite ",(0,r.yg)("em",{parentName:"p"},"very_important_var")," and enter ",(0,r.yg)("em",{parentName:"p"},"jackpot()")," function.\nAll we have to do is change the value of ",(0,r.yg)("em",{parentName:"p"},"very_important_var")," to ",(0,r.yg)("em",{parentName:"p"},"0xDEADCODE"),", when reading the buffer."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-C"},"int very_important_var = 0xDEADBEEF;\nchar buffer[32];\nfgets(buffer, 64, stdin);\nif (very_important_var == 0xDEADC0DE) {\n    jackpot();\n}\n")),(0,r.yg)("h4",{id:"infrastructure-preparation"},"Infrastructure Preparation"),(0,r.yg)("p",null,"Throughout the laboratory, in the command-line, we will use:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"nasm")," assembler"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"gcc")," command as a linker"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"objdump")," and ",(0,r.yg)("inlineCode",{parentName:"li"},"ghidra")," for disassembling object and executable files"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"gdb")," for dynamic analysis, investigation, and debugging")),(0,r.yg)("p",null,"This setup will allow us to perform assembly programming, linking, disassembly, and dynamic analysis using the specified tools in the command-line environment."),(0,r.yg)("h2",{id:"buffer-overflow-attacks"},"Buffer Overflow Attacks"),(0,r.yg)("h3",{id:"how-is-buffer-overflow-used"},"How is Buffer Overflow Used?"),(0,r.yg)("p",null,"Buffer overflow can be exploited by a potential attacker to overwrite certain data within a program, affecting the execution flow and providing specific benefits to the attacker.\nMost often, an attacker initiates a buffer overflow attack with the goal of gaining access to confidential data that a normal user would not typically have access to."),(0,r.yg)("p",null,"Buffer overflow attacks are generally used on static buffers stored at the stack level.\nThis is because the stack, in addition to program data, also stores return addresses following function calls (see laboratory 7).\nThese addresses can be overwritten through a buffer overflow attack, in which case the program's execution flow can be altered.\nBy overwriting the return address, upon completion of the current function's execution, the program will not return to the calling function's execution but will instead \"jump\" to another address within the executable where execution will continue.\nThis event can lead to undefined behavior of the program if the jump address has not been calculated correctly."),(0,r.yg)("p",null,"The goal of an attacker is to take control of a system by gaining access to a shell from which they can run commands.\nThis can be achieved by overwriting the return address, using a system call through which a shell can be opened on the system where the executable is running (more details in the OS course)."),(0,r.yg)("h3",{id:"how-do-we-protect-against-buffer-overflow-attacks"},"How Do We Protect Against Buffer Overflow Attacks?"),(0,r.yg)("p",null,"There are many ways to protect an executable from these types of attacks, most of which you will study in detail in the OS course next year.\nA good practice against this type of attack is to avoid using insecure functions, such as those mentioned above.\nMore details on best practices against buffer overflow attacks can be found ",(0,r.yg)("a",{parentName:"p",href:"https://security.web.cern.ch/recommendations/en/codetools/c.shtml"},"here"),"."),(0,r.yg)("p",null,'Often, best practices prove to be insufficient in the "battle" against hackers, which is why several executable protection mechanisms have been invented by manipulating the code and its position within the executable (',(0,r.yg)("em",{parentName:"p"},"Position Independent Code")," - ",(0,r.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Position-independent_code"},"PIC"),"), through address randomization (",(0,r.yg)("em",{parentName:"p"},"Address Space Layout Randomization")," - ",(0,r.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Address_space_layout_randomization"},"ASLR"),"), or by introducing additional checks in the code to detect potential attacks."),(0,r.yg)("p",null,"These checks are performed by introducing special values, called ",(0,r.yg)("strong",{parentName:"p"},"canaries"),", on the stack between the buffer and the function's return address.\nThese values are generated and placed within the executable by the compiler and differ with each run of the executable.\nWhen an attacker tries to overwrite the return address, they will also overwrite the canary value, and before exiting the current function call, it will be checked whether that value has been modified or not.\nIf it has been modified, it means that a buffer overflow has occurred, and the program execution will be interrupted."),(0,r.yg)("p",null,"This mechanism is called ",(0,r.yg)("strong",{parentName:"p"},"Stack Smashing Protection")," or ",(0,r.yg)("strong",{parentName:"p"},"Stack Guard"),". More details about Stack Guard and buffer overflow attacks can be found ",(0,r.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Buffer_overflow"},"here"),"."))}f.isMDXComponent=!0}}]);