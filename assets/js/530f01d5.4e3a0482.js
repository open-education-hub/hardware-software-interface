"use strict";(self.webpackChunkhardware_software_interface=self.webpackChunkhardware_software_interface||[]).push([[461],{5680:(e,t,n)=>{n.d(t,{xA:()=>p,yg:()=>y});var a=n(6540);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},g="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),g=d(n),u=i,y=g["".concat(s,".").concat(u)]||g[u]||m[u]||r;return n?a.createElement(y,o(o({ref:t},p),{},{components:n})):a.createElement(y,o({ref:t},p))}));function y(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[g]="string"==typeof e?e:i,o[1]=l;for(var d=2;d<r;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2084:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>m,frontMatter:()=>r,metadata:()=>l,toc:()=>d});var a=n(8168),i=(n(6540),n(5680));const r={},o="Lab 6 - Registers and Memory Addressing",l={unversionedId:"Labs/lab6",id:"Labs/lab6",title:"Lab 6 - Registers and Memory Addressing",description:"Task: Division of Two Numbers",source:"@site/docs/Labs/lab6.md",sourceDirName:"Labs",slug:"/Labs/lab6",permalink:"/hardware-software-interface/Labs/lab6",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Lab 5 - Introduction to Assembly Language",permalink:"/hardware-software-interface/Labs/lab5"},next:{title:"Lab 7 - Structures, Vectors and Strings",permalink:"/hardware-software-interface/Labs/lab7"}},s={},d=[{value:"Task: Division of Two Numbers",id:"task-division-of-two-numbers",level:2},{value:"Task: Multiplying Two Numbers",id:"task-multiplying-two-numbers",level:2},{value:"1. Multiplying Two Numbers represented as Bytes",id:"1-multiplying-two-numbers-represented-as-bytes",level:3},{value:"2. Multiplying Two Numbers represented as Words / Double Words",id:"2-multiplying-two-numbers-represented-as-words--double-words",level:3},{value:"Task: Sum of first N natural numbers squared",id:"task-sum-of-first-n-natural-numbers-squared",level:2},{value:"Task: Sum of Elements in an Array",id:"task-sum-of-elements-in-an-array",level:2},{value:"Introduction",id:"introduction",level:3},{value:"Sum of Elements in an Array of types word and dword",id:"sum-of-elements-in-an-array-of-types-word-and-dword",level:3},{value:"Sum of Squares of Elements in an Array",id:"sum-of-squares-of-elements-in-an-array",level:3},{value:"Task: Count Array Elements",id:"task-count-array-elements",level:2},{value:"Count Negative and Positive Numbers from Array",id:"count-negative-and-positive-numbers-from-array",level:3},{value:"Count Odd and Even Numbers from Array",id:"count-odd-and-even-numbers-from-array",level:3},{value:"Registers",id:"registers",level:2},{value:"Register Subsections",id:"register-subsections",level:3},{value:"Static Memory Region Declarations",id:"static-memory-region-declarations",level:3},{value:"Guide: Multiply and Divide",id:"guide-multiply-and-divide",level:2},{value:"Guide: Floating Point Exception",id:"guide-floating-point-exception",level:2},{value:"Memory Addressing",id:"memory-addressing",level:2},{value:"Size Directives",id:"size-directives",level:3},{value:"Loop Instruction",id:"loop-instruction",level:3},{value:"Guide: Addressing Arrays",id:"guide-addressing-arrays",level:2},{value:"Guide: Declarations",id:"guide-declarations",level:2},{value:"Guide: Loop",id:"guide-loop",level:2}],p={toc:d},g="wrapper";function m(e){let{components:t,...r}=e;return(0,i.yg)(g,(0,a.A)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"lab-6---registers-and-memory-addressing"},"Lab 6 - Registers and Memory Addressing"),(0,i.yg)("h2",{id:"task-division-of-two-numbers"},"Task: Division of Two Numbers"),(0,i.yg)("p",null,"You will solve this exercise starting from the ",(0,i.yg)("inlineCode",{parentName:"p"},"divide.asm")," file located in the ",(0,i.yg)("inlineCode",{parentName:"p"},"drills/tasks/div/support")," directory."),(0,i.yg)("p",null,"In the ",(0,i.yg)("inlineCode",{parentName:"p"},"divide.asm")," program, the quotient and remainder of two numbers represented as bytes are calculated.\nUpdate the area marked with ",(0,i.yg)("inlineCode",{parentName:"p"},"TODO")," to perform divisions ",(0,i.yg)("inlineCode",{parentName:"p"},"dividend2 / divisor2")," (word-type divisor) and ",(0,i.yg)("inlineCode",{parentName:"p"},"dividend3 / divisor3")," (dword-type divisor)."),(0,i.yg)("p",null,"Similar to the ",(0,i.yg)("inlineCode",{parentName:"p"},"mul")," instruction, the registers where the dividend is placed vary depending on the representation size of the divisor.\nThe divisor is passed as an argument to the ",(0,i.yg)("inlineCode",{parentName:"p"},"div")," mnemonic."),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"TIP"),": If the divisor is of type ",(0,i.yg)("inlineCode",{parentName:"p"},"byte")," (8 bits), the components are arranged as follows:"),(0,i.yg)("ul",{parentName:"blockquote"},(0,i.yg)("li",{parentName:"ul"},"the dividend is placed in the ",(0,i.yg)("inlineCode",{parentName:"li"},"ax")," register"),(0,i.yg)("li",{parentName:"ul"},"the argument of the ",(0,i.yg)("inlineCode",{parentName:"li"},"div")," instruction is 8 bits and can be represented by a register or an immediate value"),(0,i.yg)("li",{parentName:"ul"},"the quotient is placed in ",(0,i.yg)("inlineCode",{parentName:"li"},"al")),(0,i.yg)("li",{parentName:"ul"},"the remainder is placed in ",(0,i.yg)("inlineCode",{parentName:"li"},"ah"))),(0,i.yg)("p",{parentName:"blockquote"},"If the divisor is of type ",(0,i.yg)("inlineCode",{parentName:"p"},"word")," (16 bits), the components are arranged as follows:"),(0,i.yg)("ul",{parentName:"blockquote"},(0,i.yg)("li",{parentName:"ul"},"the dividend is arranged in the ",(0,i.yg)("inlineCode",{parentName:"li"},"dx:ax")," pair, meaning its ",(0,i.yg)("inlineCode",{parentName:"li"},"high")," part is in the ",(0,i.yg)("inlineCode",{parentName:"li"},"dx")," register, and the ",(0,i.yg)("inlineCode",{parentName:"li"},"low")," part is in ",(0,i.yg)("inlineCode",{parentName:"li"},"ax")),(0,i.yg)("li",{parentName:"ul"},"the argument of the ",(0,i.yg)("inlineCode",{parentName:"li"},"div")," instruction is 16 bits and can be represented by a register or an immediate value"),(0,i.yg)("li",{parentName:"ul"},"the quotient is placed in ",(0,i.yg)("inlineCode",{parentName:"li"},"ax")),(0,i.yg)("li",{parentName:"ul"},"the remainder is placed in ",(0,i.yg)("inlineCode",{parentName:"li"},"dx"))),(0,i.yg)("p",{parentName:"blockquote"},"If the divisor is of type ",(0,i.yg)("inlineCode",{parentName:"p"},"dword")," (32 bits), the components are arranged as follows:"),(0,i.yg)("ul",{parentName:"blockquote"},(0,i.yg)("li",{parentName:"ul"},"the dividend is arranged in the ",(0,i.yg)("inlineCode",{parentName:"li"},"edx:eax")," pair, meaning its ",(0,i.yg)("inlineCode",{parentName:"li"},"high")," part is in the ",(0,i.yg)("inlineCode",{parentName:"li"},"edx")," register, and the ",(0,i.yg)("inlineCode",{parentName:"li"},"low")," part is in ",(0,i.yg)("inlineCode",{parentName:"li"},"eax")),(0,i.yg)("li",{parentName:"ul"},"the argument of the ",(0,i.yg)("inlineCode",{parentName:"li"},"div")," instruction is 32 bits and can be represented by a register or an immediate value"),(0,i.yg)("li",{parentName:"ul"},"the quotient is placed in ",(0,i.yg)("inlineCode",{parentName:"li"},"eax")),(0,i.yg)("li",{parentName:"ul"},"the remainder is placed in ",(0,i.yg)("inlineCode",{parentName:"li"},"edx"))),(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"TIP"),": If the program gives you a ",(0,i.yg)("inlineCode",{parentName:"p"},"SIGFPE"),'.\nArithmetic exception," you most likely forgot to initialize the upper part of the dividend (',(0,i.yg)("inlineCode",{parentName:"p"},"ah"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"dx"),", or ",(0,i.yg)("inlineCode",{parentName:"p"},"edx"),").")),(0,i.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,i.yg)("a",{parentName:"p",href:"/hardware-software-interface/Labs/lab6#registers"},"this")," reading material."),(0,i.yg)("h2",{id:"task-multiplying-two-numbers"},"Task: Multiplying Two Numbers"),(0,i.yg)("h3",{id:"1-multiplying-two-numbers-represented-as-bytes"},"1. Multiplying Two Numbers represented as Bytes"),(0,i.yg)("p",null,"You will solve this exercise starting from the ",(0,i.yg)("inlineCode",{parentName:"p"},"multiply.asm")," file located in the ",(0,i.yg)("inlineCode",{parentName:"p"},"drills/tasks/mul/support")," directory."),(0,i.yg)("p",null,"Go through, run, and test the code from the file ",(0,i.yg)("inlineCode",{parentName:"p"},"multiply.asm"),".\nIn this program, we multiply two numbers defined as bytes.\nTo access them, we use a construction like ",(0,i.yg)("inlineCode",{parentName:"p"},"byte [register]"),"."),(0,i.yg)("p",null,"When performing multiplication, the process is as follows, as described ",(0,i.yg)("a",{parentName:"p",href:"https://en.wikibooks.org/wiki/X86_Assembly/Arithmetic"},"here"),":"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"We place the multiplicand in the multiplicand register, meaning:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"if we're operating on a byte (8 bits, one byte), we place the multiplicand in the ",(0,i.yg)("inlineCode",{parentName:"li"},"al")," register;"),(0,i.yg)("li",{parentName:"ul"},"if we're operating on a word (16 bits, 2 bytes), we place the multiplicand in the ",(0,i.yg)("inlineCode",{parentName:"li"},"ax")," register;"),(0,i.yg)("li",{parentName:"ul"},"if we're operating on a double word (32 bits, 4 bytes), we place the multiplicand in the ",(0,i.yg)("inlineCode",{parentName:"li"},"eax")," register."))),(0,i.yg)("li",{parentName:"ol"},"The multiplier is passed as an argument to the ",(0,i.yg)("inlineCode",{parentName:"li"},"mul")," mnemonic.\nThe multiplier must have the same size as the multiplicand."),(0,i.yg)("li",{parentName:"ol"},"The result is placed in two registers (the high part and the low part).")),(0,i.yg)("h3",{id:"2-multiplying-two-numbers-represented-as-words--double-words"},"2. Multiplying Two Numbers represented as Words / Double Words"),(0,i.yg)("p",null,"Update the area marked with ",(0,i.yg)("inlineCode",{parentName:"p"},"TODO")," in the file ",(0,i.yg)("inlineCode",{parentName:"p"},"multiply.asm")," to allow multiplication of ",(0,i.yg)("inlineCode",{parentName:"p"},"word")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"dword")," numbers, namely ",(0,i.yg)("inlineCode",{parentName:"p"},"num1_dw")," with ",(0,i.yg)("inlineCode",{parentName:"p"},"num2_dw"),", and ",(0,i.yg)("inlineCode",{parentName:"p"},"num1_dd")," with ",(0,i.yg)("inlineCode",{parentName:"p"},"num2_dd"),"."),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"TIP"),": For multiplying word numbers (16 bits), the components are arranged as follows:"),(0,i.yg)("ul",{parentName:"blockquote"},(0,i.yg)("li",{parentName:"ul"},"Place the multiplicand in the ",(0,i.yg)("inlineCode",{parentName:"li"},"ax")," register."),(0,i.yg)("li",{parentName:"ul"},"The argument of the ",(0,i.yg)("inlineCode",{parentName:"li"},"mul")," instruction, the multiplier (possibly another register), is 16 bits (either a value or a register such as ",(0,i.yg)("inlineCode",{parentName:"li"},"bx"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"cx"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"dx"),")."),(0,i.yg)("li",{parentName:"ul"},"The result of the multiplication is arranged in the pair ",(0,i.yg)("inlineCode",{parentName:"li"},"dx:ax"),", where the high part of the result is in the ",(0,i.yg)("inlineCode",{parentName:"li"},"dx")," register, and the low part of the result is in the ",(0,i.yg)("inlineCode",{parentName:"li"},"ax")," register.")),(0,i.yg)("p",{parentName:"blockquote"},"For multiplying ",(0,i.yg)("inlineCode",{parentName:"p"},"dword")," numbers (32 bits), the components are arranged as follows:"),(0,i.yg)("ul",{parentName:"blockquote"},(0,i.yg)("li",{parentName:"ul"},"Place the multiplicand in the ",(0,i.yg)("inlineCode",{parentName:"li"},"eax")," register."),(0,i.yg)("li",{parentName:"ul"},"The argument of the ",(0,i.yg)("inlineCode",{parentName:"li"},"mul")," instruction, the multiplier (possibly another register), is 32 bits (either a value or a register such as ",(0,i.yg)("inlineCode",{parentName:"li"},"ebx"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"ecx"),", ",(0,i.yg)("inlineCode",{parentName:"li"},"edx"),")."),(0,i.yg)("li",{parentName:"ul"},"The result of the multiplication is arranged in the pair ",(0,i.yg)("inlineCode",{parentName:"li"},"edx:eax"),", where the high part of the result is in the ",(0,i.yg)("inlineCode",{parentName:"li"},"edx")," register, and the low part of the result is in the ",(0,i.yg)("inlineCode",{parentName:"li"},"eax")," register.")),(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"NOTE"),": When displaying the result, use the ",(0,i.yg)("inlineCode",{parentName:"p"},"PRINTF32")," macro to display the two registers containing the result:"),(0,i.yg)("ul",{parentName:"blockquote"},(0,i.yg)("li",{parentName:"ul"},"Registers ",(0,i.yg)("inlineCode",{parentName:"li"},"dx")," and ",(0,i.yg)("inlineCode",{parentName:"li"},"ax")," for multiplying word numbers."),(0,i.yg)("li",{parentName:"ul"},"Registers ",(0,i.yg)("inlineCode",{parentName:"li"},"edx")," and ",(0,i.yg)("inlineCode",{parentName:"li"},"eax")," for multiplying dword numbers."))),(0,i.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,i.yg)("a",{parentName:"p",href:"/hardware-software-interface/Labs/lab6#registers"},"this")," reading material."),(0,i.yg)("h2",{id:"task-sum-of-first-n-natural-numbers-squared"},"Task: Sum of first N natural numbers squared"),(0,i.yg)("p",null,"You will solve this exercise starting from the ",(0,i.yg)("inlineCode",{parentName:"p"},"sum_n.asm")," file located in the ",(0,i.yg)("inlineCode",{parentName:"p"},"drills/tasks/sum-squared/support")," directory."),(0,i.yg)("p",null,"In the ",(0,i.yg)("inlineCode",{parentName:"p"},"sum_n.asm")," program, the sum of the first ",(0,i.yg)("inlineCode",{parentName:"p"},"num")," natural numbers is calculated."),(0,i.yg)("p",null,"Follow the code, observe the constructions and registers specific to working with bytes.\nRun the code."),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"IMPORTANT"),": Proceed to the next step only after you have understood very well what the code does.\nIt will be difficult for you to do the next exercise if you have difficulties understanding the current one.")),(0,i.yg)("p",null,"Start with the program ",(0,i.yg)("inlineCode",{parentName:"p"},"sum_n.asm")," and create a program ",(0,i.yg)("inlineCode",{parentName:"p"},"sum_n_square.asm")," that calculates the sum of squares of the first ",(0,i.yg)("inlineCode",{parentName:"p"},"num")," natural numbers (",(0,i.yg)("inlineCode",{parentName:"p"},"num")," <= 100)."),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"TIP"),": You will use the ",(0,i.yg)("inlineCode",{parentName:"p"},"eax")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"edx")," registers for multiplication to compute the squares (using the ",(0,i.yg)("inlineCode",{parentName:"p"},"mul")," instruction).\nTherefore, you cannot easily use the ",(0,i.yg)("inlineCode",{parentName:"p"},"eax")," register to store the sum of squares. To retain the sum of squares, you have two options:"),(0,i.yg)("ol",{parentName:"blockquote"},(0,i.yg)("li",{parentName:"ol"},"(easier) Use the ",(0,i.yg)("inlineCode",{parentName:"li"},"ebx")," register to store the sum of squares."),(0,i.yg)("li",{parentName:"ol"},"(more complex) Before performing operations on the ",(0,i.yg)("inlineCode",{parentName:"li"},"eax")," register, save its value on the stack (using the ",(0,i.yg)("inlineCode",{parentName:"li"},"push")," instruction), then perform the necessary operations, and finally restore the saved value (using the ",(0,i.yg)("inlineCode",{parentName:"li"},"pop")," instruction).")),(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"NOTE"),": For verification, the sum of squares of the first 100 natural numbers is ",(0,i.yg)("inlineCode",{parentName:"p"},"338350"),".")),(0,i.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,i.yg)("a",{parentName:"p",href:"/hardware-software-interface/Labs/lab6#registers"},"this")," reading material."),(0,i.yg)("h2",{id:"task-sum-of-elements-in-an-array"},"Task: Sum of Elements in an Array"),(0,i.yg)("h3",{id:"introduction"},"Introduction"),(0,i.yg)("p",null,"You will solve this exercise starting from the ",(0,i.yg)("inlineCode",{parentName:"p"},"sum-array.asm")," file located in the ",(0,i.yg)("inlineCode",{parentName:"p"},"drills/tasks/sum-array/support")," directory."),(0,i.yg)("p",null,"In the ",(0,i.yg)("inlineCode",{parentName:"p"},"sum-array.asm")," file the sum of elements in an array of bytes (8-bit representation) is calculated."),(0,i.yg)("p",null,"Follow the code, observe the constructions and registers specific for working with bytes.\nRun the code."),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"IMPORTANT"),": Proceed to the next step only after thoroughly understanding what the code does.\nIt will be difficult for you to complete the following exercises if you have difficulty understanding the current exercise.")),(0,i.yg)("h3",{id:"sum-of-elements-in-an-array-of-types-word-and-dword"},"Sum of Elements in an Array of types word and dword"),(0,i.yg)("p",null,"In the ",(0,i.yg)("inlineCode",{parentName:"p"},"TODO")," section of the ",(0,i.yg)("inlineCode",{parentName:"p"},"sum-array.asm")," file, complete the code to calculate the sum of arrays with elements of type word (16 bits) and dword (32 bits);\nnamely, the ",(0,i.yg)("inlineCode",{parentName:"p"},"word_array")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"dword_array"),"."),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"TIP"),": When calculating the address of an element in an array, you will use a construction like:"),(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("inlineCode",{parentName:"p"},"base + size * index")),(0,i.yg)("p",{parentName:"blockquote"},"In the construction above:"),(0,i.yg)("ul",{parentName:"blockquote"},(0,i.yg)("li",{parentName:"ul"},"base is the address of the array (i.e., ",(0,i.yg)("inlineCode",{parentName:"li"},"word_array")," or ",(0,i.yg)("inlineCode",{parentName:"li"},"dword_array"),")"),(0,i.yg)("li",{parentName:"ul"},"size is the length of the array element (i.e., 2 for a word array (16 bits, 2 bytes) and 4 for a dword array (32 bits, 4 bytes))"),(0,i.yg)("li",{parentName:"ul"},"index is the current index within the array")),(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"NOTE"),": The sum of elements in the three arrays should be:"),(0,i.yg)("ul",{parentName:"blockquote"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"sum(byte_array): 575")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"sum(word_array): 65799")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"sum(dword_array): 74758117")))),(0,i.yg)("h3",{id:"sum-of-squares-of-elements-in-an-array"},"Sum of Squares of Elements in an Array"),(0,i.yg)("p",null,"Starting from the program in the previous exercise, calculate the sum of squares of elements in an array."),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"NOTE"),": You can use the ",(0,i.yg)("inlineCode",{parentName:"p"},"dword_array")," array, ensuring that the sum of squares of the contained elements can be represented in 32 bits."),(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"NOTE"),": If you use the construction below (array with 10 elements)"),(0,i.yg)("pre",{parentName:"blockquote"},(0,i.yg)("code",{parentName:"pre",className:"language-Assembly"},"dword_array dd 1392, 12544, 7992, 6992, 7202, 27187, 28789, 17897, 12988, 17992\n")),(0,i.yg)("p",{parentName:"blockquote"},"the sum of squares will be 2704560839.")),(0,i.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,i.yg)("a",{parentName:"p",href:"/hardware-software-interface/Labs/lab6#memory-addressing"},"this")," reading material."),(0,i.yg)("h2",{id:"task-count-array-elements"},"Task: Count Array Elements"),(0,i.yg)("h3",{id:"count-negative-and-positive-numbers-from-array"},"Count Negative and Positive Numbers from Array"),(0,i.yg)("p",null,"You will solve this exercise starting from the ",(0,i.yg)("inlineCode",{parentName:"p"},"count_pos_neg.asm")," file located in the ",(0,i.yg)("inlineCode",{parentName:"p"},"drills/tasks/vec-count-if/support")," directory."),(0,i.yg)("p",null,"Your program should display the number of positive and negative values from the array."),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"NOTE"),": Define a vector that contains both negative and positive numbers."),(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"TIP"),": Use the ",(0,i.yg)("inlineCode",{parentName:"p"},"cmp")," instruction and conditional jump mnemonics. See details ",(0,i.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/X86_instruction_listings"},"here"),"."),(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"TIP"),": The ",(0,i.yg)("inlineCode",{parentName:"p"},"inc")," instruction followed by a register increments the value stored in that register.")),(0,i.yg)("h3",{id:"count-odd-and-even-numbers-from-array"},"Count Odd and Even Numbers from Array"),(0,i.yg)("p",null,"Create a new file called ",(0,i.yg)("inlineCode",{parentName:"p"},"count_even_odd.asm")," file located in the ",(0,i.yg)("inlineCode",{parentName:"p"},"drills/tasks/vec-count-if/support")," directory."),(0,i.yg)("p",null,"Your program should display the number of even and odd values from an array."),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"TIP"),": You can use the ",(0,i.yg)("inlineCode",{parentName:"p"},"div")," instruction to divide a number by 2 and then compare the remainder of the division with 0."),(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"NOTE"),": For testing, use an array containing only positive numbers.")),(0,i.yg)("p",null,"For negative numbers, sign extension should be performed; it would work without it because we are only interested in the remainder, but let's be rigorous :-)"),(0,i.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,i.yg)("a",{parentName:"p",href:"/hardware-software-interface/Labs/lab6#memory-addressing"},"this")," reading material."),(0,i.yg)("h2",{id:"registers"},"Registers"),(0,i.yg)("p",null,'Registers are the primary "tools" used to write programs in assembly language.\nThey are like variables built into the processor.\nUsing registers instead of direct memory addressing makes developing and reading assembly-written programs faster and easier.\nThe only disadvantage of programming in x86 assembly language is that there are few registers.'),(0,i.yg)("p",null,"Modern x86 processors have 8 general-purpose registers whose size is 32 bits.\nThe names of the registers are of historical nature (for example: ",(0,i.yg)("inlineCode",{parentName:"p"},"eax")," was called the accumulator register because it is used by a series of arithmetic instructions, such as ",(0,i.yg)("a",{parentName:"p",href:"https://www.felixcloutier.com/x86/idiv"},"idiv"),').\nWhile most registers have lost their special purpose, becoming "general purpose" in the modern ISA (',(0,i.yg)("inlineCode",{parentName:"p"},"eax"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"ebx"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"ecx"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"edx"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"esi"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"edi"),"), by convention, 2 have retained their initial purpose: ",(0,i.yg)("inlineCode",{parentName:"p"},"esp")," (stack pointer) and ",(0,i.yg)("inlineCode",{parentName:"p"},"ebp")," (base pointer)."),(0,i.yg)("h3",{id:"register-subsections"},"Register Subsections"),(0,i.yg)("p",null,"In certain cases, we want to manipulate values that are represented in less than 4 bytes (for example, working with character strings).\nFor these situations, x86 processors offer us the possibility to work with subsections of 1 and 2 bytes of the ",(0,i.yg)("inlineCode",{parentName:"p"},"eax"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"ebx"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"ecx"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"edx")," registers."),(0,i.yg)("p",null,"The image below represents the registers, their subsections, and their sizes."),(0,i.yg)("p",null,(0,i.yg)("img",{alt:"x86_32 Registers",src:n(3681).A})),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"WARNING"),": Subsections are part of registers, which means that if we modify a register, we implicitly modify the value of the subsection."),(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"NOTE"),": Subsections are used in the same way as registers, only the size of the retained value is different."),(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"NOTE"),": Besides the basic registers, there are also six segment registers corresponding to certain areas as seen in the image:"),(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("img",{alt:"Segment Registers",src:n(2275).A}))),(0,i.yg)("h3",{id:"static-memory-region-declarations"},"Static Memory Region Declarations"),(0,i.yg)("p",null,"Static memory declarations (analogous to declaring global variables) in the x86 world are made through special assembly directives.\nThese declarations are made in the data section (the ",(0,i.yg)("inlineCode",{parentName:"p"},".data")," region).\nNames can be attached to the declared memory portions through a label to easily reference them later in the program. Follow the example below:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-Assembly"},'.DATA\n    var        `db` 64    ; Declares a byte containing the value 64. Labels\n                        ; the memory location as "var".\n    var2       `db` ?     ; Declares an uninitialized byte labeled "var2".\n               `db` 10    ; Declares an unlabeled byte, initialized with 10. This\n                        ; byte will be placed at the address (var2 + 1).\n    X          `dw` ?     ; Declares an uninitialized word (2 bytes), labeled "X".\n    Y          `dd` 3000  ; Declares a double word (4 bytes) labeled "Y",\n                        ; initialized with the value 3000.\n    Z          `dd` 1,2,3 ; Declares 3 double words (each 4 bytes)\n                        ; starting from address "Z" and initialized with 1, 2, and 3, respectively.\n                        ; For example, 3 will be placed at the address (Z + 8).\n')),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"NOTE"),": DB, DW, DD are directives used to specify the size of the portion:"),(0,i.yg)("table",{parentName:"blockquote"},(0,i.yg)("thead",{parentName:"table"},(0,i.yg)("tr",{parentName:"thead"},(0,i.yg)("th",{parentName:"tr",align:null},"Directive"),(0,i.yg)("th",{parentName:"tr",align:null},"Role"),(0,i.yg)("th",{parentName:"tr",align:null},"Size"))),(0,i.yg)("tbody",{parentName:"table"},(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"db")),(0,i.yg)("td",{parentName:"tr",align:null},"Define Byte"),(0,i.yg)("td",{parentName:"tr",align:null},"1 bytes (8 bits)")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"dw")),(0,i.yg)("td",{parentName:"tr",align:null},"Define Word"),(0,i.yg)("td",{parentName:"tr",align:null},"2 bytes (16 bits)")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"dd")),(0,i.yg)("td",{parentName:"tr",align:null},"Define Double Word"),(0,i.yg)("td",{parentName:"tr",align:null},"4 bytes (32 bits)")))),(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"NOTE"),": There are multiple types of memory regions as can be seen in the image below:"),(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("img",{alt:"Memory Sections",src:n(9370).A,width:"640",height:"480"}))),(0,i.yg)("p",null,"The last declaration in the above example represents the declaration of an array.\nUnlike higher-level languages, where arrays can have multiple dimensions and their elements are accessed by indices, in assembly language, arrays are represented as a number of cells located in a contiguous area of memory."),(0,i.yg)("h2",{id:"guide-multiply-and-divide"},"Guide: Multiply and Divide"),(0,i.yg)("p",null,"To follow this guide, you'll need to use the ",(0,i.yg)("inlineCode",{parentName:"p"},"multiply-divide.asm")," file located in the ",(0,i.yg)("inlineCode",{parentName:"p"},"guides/multiply-divide/support")," directory."),(0,i.yg)("p",null,"The program performs the ",(0,i.yg)("inlineCode",{parentName:"p"},"mul")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"div")," instructions and prints out the results."),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"Note"),": For a detailed description of the instruction check out the following pages: ",(0,i.yg)("a",{parentName:"p",href:"https://www.felixcloutier.com/x86/div"},"div")," and ",(0,i.yg)("a",{parentName:"p",href:"https://www.felixcloutier.com/x86/mul"},"mul"))),(0,i.yg)("h2",{id:"guide-floating-point-exception"},"Guide: Floating Point Exception"),(0,i.yg)("p",null,"To follow this guide, you'll need to use the ",(0,i.yg)("inlineCode",{parentName:"p"},"floating_point_exception.asm")," file located in the ",(0,i.yg)("inlineCode",{parentName:"p"},"guides/floating-point-exception/support")," directory."),(0,i.yg)("p",null,"The program tries to perform division using an ",(0,i.yg)("inlineCode",{parentName:"p"},"8 bit")," operand, ",(0,i.yg)("inlineCode",{parentName:"p"},"bl"),", in this case the quotient should be in the range ","[0, 255]",".\nGiven that ",(0,i.yg)("inlineCode",{parentName:"p"},"ax")," is ",(0,i.yg)("inlineCode",{parentName:"p"},"22891")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"bl")," is ",(0,i.yg)("inlineCode",{parentName:"p"},"2"),", the result of the division would be out of the defined range.\nThus we will see a ",(0,i.yg)("inlineCode",{parentName:"p"},"Floating point exception")," after the division."),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"Note"),": For a detailed description of the ",(0,i.yg)("inlineCode",{parentName:"p"},"div")," instruction check out the ",(0,i.yg)("a",{parentName:"p",href:"https://www.felixcloutier.com/x86/idiv"},"documentation"),".")),(0,i.yg)("h2",{id:"memory-addressing"},"Memory Addressing"),(0,i.yg)("p",null,"Modern x86 processors can address up to 2^32 bytes of memory, which means memory addresses are represented on 32 bits.\nTo address memory, the processor uses addresses (implicitly, each label is translated into a corresponding memory address).\nBesides labels, there are other forms of addressing memory:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-Assembly"},"mov eax, [0xcafebab3]         ; direct (displacement)\nmov eax, [esi]                ; indirect (base)\nmov eax, [ebp-8]              ; based (base + displacement)\nmov eax, [ebx*4 + 0xdeadbeef] ; indexed (index * scale + displacement)\nmov eax, [edx + ebx + 12]     ; based and indexed without scale (base + index + displacement)\nmov eax, [edx + ebx*4 + 42]   ; based and indexed with scale (base + index * scale + displacement)\n")),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"WARNING"),": The following addressing modes are invalid:"),(0,i.yg)("pre",{parentName:"blockquote"},(0,i.yg)("code",{parentName:"pre",className:"language-Assembly"},"mov eax, [ebx-ecx]     ; Registers can only be added\nmov [eax+esi+edi], ebx ; The address calculation can involve at most 2 registers\n"))),(0,i.yg)("h3",{id:"size-directives"},"Size Directives"),(0,i.yg)("p",null,"Generally, the size of a value brought from memory can be inferred from the instruction code used.\nFor example, in the above addressing modes, the size of the values could be inferred from the size of the destination register, but in some cases, this is not so obvious.\nLet's consider the following instruction:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-Assembly"},"mov [ebx], 2\n")),(0,i.yg)("p",null,"As seen, it intends to store the value 2 at the address contained in the ",(0,i.yg)("inlineCode",{parentName:"p"},"ebx")," register.\nThe size of the register is 4 bytes.\nThe value 2 can be represented on both 1 and 4 bytes.\nIn this case, since both interpretations are valid, the processor needs additional information on how to treat this value.\nThis can be done through size directives:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-Assembly"},"mov byte [ebx], 2  ; Move the value 2 into the byte at the address contained in ebx.\nmov word [ebx], 2  ; Move the entire 2 represented in 16 bits into the 2 bytes\n                   ; starting from the address contained in ebx.\nmov dword [ebx], 2 ; Move the entire 2 represented in 32 bits into the 4 bytes\n                   ; starting from the address contained in ebx.\n")),(0,i.yg)("h3",{id:"loop-instruction"},"Loop Instruction"),(0,i.yg)("p",null,"The loop instruction is used for loops with a predetermined number of iterations, loaded into the ",(0,i.yg)("inlineCode",{parentName:"p"},"ecx")," register.\nIts syntax is as follows:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-Assembly"},"mov ecx, 10 ; Initialize ecx with the number of iterations\nlabel:\n; loop content\nloop label\n")),(0,i.yg)("p",null,"At each iteration, the ",(0,i.yg)("inlineCode",{parentName:"p"},"ecx")," register is decremented, and if it's not equal to 0, the execution jumps to the specified label.\nThere are other forms of the instruction that additionally check the ",(0,i.yg)("inlineCode",{parentName:"p"},"ZF")," flag:"),(0,i.yg)("table",null,(0,i.yg)("thead",{parentName:"table"},(0,i.yg)("tr",{parentName:"thead"},(0,i.yg)("th",{parentName:"tr",align:null},"Mnemonic"),(0,i.yg)("th",{parentName:"tr",align:null},"Description"))),(0,i.yg)("tbody",{parentName:"table"},(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"loope/loopz label")),(0,i.yg)("td",{parentName:"tr",align:null},"Decrement ",(0,i.yg)("inlineCode",{parentName:"td"},"ecx"),", jump to label if ",(0,i.yg)("inlineCode",{parentName:"td"},"ecx != 0")," and ",(0,i.yg)("inlineCode",{parentName:"td"},"ZF == 1"))),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},(0,i.yg)("inlineCode",{parentName:"td"},"loopne/loopnz label")),(0,i.yg)("td",{parentName:"tr",align:null},"Decrement ",(0,i.yg)("inlineCode",{parentName:"td"},"ecx"),", jump to label if ",(0,i.yg)("inlineCode",{parentName:"td"},"ecx != 0")," and ",(0,i.yg)("inlineCode",{parentName:"td"},"ZF != 1"))))),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"NOTE"),": When using jumps in an assembly language program, it's important to consider the difference between a ",(0,i.yg)("inlineCode",{parentName:"p"},"short jump")," (near jump) and a ",(0,i.yg)("inlineCode",{parentName:"p"},"long jump")," (far jump)."),(0,i.yg)("table",{parentName:"blockquote"},(0,i.yg)("thead",{parentName:"table"},(0,i.yg)("tr",{parentName:"thead"},(0,i.yg)("th",{parentName:"tr",align:null},"Type and example"),(0,i.yg)("th",{parentName:"tr",align:null},"Size and significance"),(0,i.yg)("th",{parentName:"tr",align:null},"Description"))),(0,i.yg)("tbody",{parentName:"table"},(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"Short Jump (loop)"),(0,i.yg)("td",{parentName:"tr",align:null},"2 bytes (one byte for the opcode and one for the address)"),(0,i.yg)("td",{parentName:"tr",align:null},"The relative address of the instruction to which the jump is intended must not be more than 128 bytes away from the current instruction address.")),(0,i.yg)("tr",{parentName:"tbody"},(0,i.yg)("td",{parentName:"tr",align:null},"Long Jump (jmp)"),(0,i.yg)("td",{parentName:"tr",align:null},"3 bytes (one byte for the opcode and two for the address)"),(0,i.yg)("td",{parentName:"tr",align:null},"The relative address of the instruction to which the jump is intended must not be more than 32768 bytes away from the current instruction address."))))),(0,i.yg)("h2",{id:"guide-addressing-arrays"},"Guide: Addressing Arrays"),(0,i.yg)("p",null,"To follow this guide, you'll need to use the ",(0,i.yg)("inlineCode",{parentName:"p"},"addressing_arrays.asm")," file located in the ",(0,i.yg)("inlineCode",{parentName:"p"},"guides/addressing-arrays/support")," directory."),(0,i.yg)("p",null,"The program increments the values of an array of 10 integers by 1 and iterates through the array before and after to show the changes."),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"Note:")," ",(0,i.yg)("inlineCode",{parentName:"p"},"ecx")," is used as the loop counter.\nSince the array contains ",(0,i.yg)("inlineCode",{parentName:"p"},"dwords")," (4 bytes), the loop counter is multiplied by 4 to get the address of the next element in the array.")),(0,i.yg)("h2",{id:"guide-declarations"},"Guide: Declarations"),(0,i.yg)("p",null,"To follow this guide, you'll need to use the ",(0,i.yg)("inlineCode",{parentName:"p"},"declarations.asm")," file located in the ",(0,i.yg)("inlineCode",{parentName:"p"},"guides/declarations/support")," directory."),(0,i.yg)("p",null,"The program declares multiple variables of different sizes in the ",(0,i.yg)("inlineCode",{parentName:"p"},".bss")," and ",(0,i.yg)("inlineCode",{parentName:"p"},".data")," sections."),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"Note"),": When defining strings, make sure to add a zero byte at the end, in order to mark the end of the string."),(0,i.yg)("pre",{parentName:"blockquote"},(0,i.yg)("code",{parentName:"pre",className:"language-Assembly"},'decimal_point   db ".",0\n'))),(0,i.yg)("p",null,"For a complete set of the pseudo-instruction check out the ",(0,i.yg)("inlineCode",{parentName:"p"},"nasm")," ",(0,i.yg)("a",{parentName:"p",href:"https://nasm.us/doc/nasmdoc3.html"},"documentation"),"."),(0,i.yg)("h2",{id:"guide-loop"},"Guide: Loop"),(0,i.yg)("p",null,"To follow this guide, you'll need to use the ",(0,i.yg)("inlineCode",{parentName:"p"},"loop.asm")," file located in the ",(0,i.yg)("inlineCode",{parentName:"p"},"guides/loop/support")," directory."),(0,i.yg)("p",null,"This program illustrates how to use the ",(0,i.yg)("inlineCode",{parentName:"p"},"loop")," instruction, as well as how to index an array of ",(0,i.yg)("inlineCode",{parentName:"p"},"dwords"),"."),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"Note"),": The ",(0,i.yg)("inlineCode",{parentName:"p"},"loop")," instruction jumps to the given label when the ",(0,i.yg)("inlineCode",{parentName:"p"},"count")," register is not equal to 0.\nIn the case of ",(0,i.yg)("inlineCode",{parentName:"p"},"x86")," the ",(0,i.yg)("inlineCode",{parentName:"p"},"count")," register is ",(0,i.yg)("inlineCode",{parentName:"p"},"ecx"),"."),(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"Note"),": For a detailed description of the ",(0,i.yg)("inlineCode",{parentName:"p"},"loop")," instruction check out the ",(0,i.yg)("a",{parentName:"p",href:"https://www.felixcloutier.com/x86/loop:loopcc"},"documentation"),".")))}m.isMDXComponent=!0},3681:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/registers-0db2e8e77041c8e0b8e0454074e866a8.svg"},9370:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/sections-bd531a20bf90f40ab1dc04a208f1264d.jpg"},2275:(e,t,n)=>{n.d(t,{A:()=>a});const a=n.p+"assets/images/segments-48963525b46d75a87b71f2fbdc282e44.svg"}}]);