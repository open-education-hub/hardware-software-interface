"use strict";(self.webpackChunkhardware_software_interface=self.webpackChunkhardware_software_interface||[]).push([[756],{5680:(e,n,t)=>{t.d(n,{xA:()=>p,yg:()=>g});var a=t(6540);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=a.createContext({}),m=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=m(e.components);return a.createElement(l.Provider,{value:n},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=m(t),d=i,g=c["".concat(l,".").concat(d)]||c[d]||u[d]||r;return t?a.createElement(g,o(o({ref:n},p),{},{components:t})):a.createElement(g,o({ref:n},p))}));function g(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[c]="string"==typeof e?e:i,o[1]=s;for(var m=2;m<r;m++)o[m]=t[m];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},6237:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>m});var a=t(8168),i=(t(6540),t(5680));const r={},o="Lab 10 - The C - Assembly Interaction",s={unversionedId:"Labs/lab10",id:"Labs/lab10",title:"Lab 10 - The C - Assembly Interaction",description:"Task: Maximum Calculation in Assembly with Call from C",source:"@site/docs/Labs/lab10.md",sourceDirName:"Labs",slug:"/Labs/lab10",permalink:"/hardware-software-interface/Labs/lab10",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Lab 9 - Functions",permalink:"/hardware-software-interface/Labs/lab9"},next:{title:"Lab 11 - Buffer Management. Buffer Overflow",permalink:"/hardware-software-interface/Labs/lab11"}},l={},m=[{value:"Task: Maximum Calculation in Assembly with Call from C",id:"task-maximum-calculation-in-assembly-with-call-from-c",level:2},{value:"Maximum Computation Extension in Assembly with Call from C",id:"maximum-computation-extension-in-assembly-with-call-from-c",level:3},{value:"Task: Corrupt Stack Frame Debugging",id:"task-corrupt-stack-frame-debugging",level:2},{value:"Task: Maximum Calculation in C with Call from Assembly",id:"task-maximum-calculation-in-c-with-call-from-assembly",level:2},{value:"Extending Maximum Computation in C with Call from Assembly",id:"extending-maximum-computation-in-c-with-call-from-assembly",level:3},{value:"Task: Keeping Records",id:"task-keeping-records",level:2},{value:"Troubleshooting SEGFAULT",id:"troubleshooting-segfault",level:3},{value:"Task: Warning (not an error)",id:"task-warning-not-an-error",level:2},{value:"Task: Fixing Export Issues",id:"task-fixing-export-issues",level:2},{value:"Task: Maximum Computation in Assembly with 64-bit C Call",id:"task-maximum-computation-in-assembly-with-64-bit-c-call",level:2},{value:"Task: Bonus: Maximum Calculation in C with Call from Assembly - 64 Bits",id:"task-bonus-maximum-calculation-in-c-with-call-from-assembly---64-bits",level:2},{value:"C - Assembly Interaction: Memory Perspective",id:"c---assembly-interaction-memory-perspective",level:2},{value:"Using Assembly Procedures in C Functions",id:"using-assembly-procedures-in-c-functions",level:3},{value:"Declaration of the Procedure",id:"declaration-of-the-procedure",level:4},{value:"Calling C Functions from Assembly Procedures",id:"calling-c-functions-from-assembly-procedures",level:3},{value:"C - Assembly Interaction: Stack",id:"c---assembly-interaction-stack",level:2},{value:"Setting the Stack",id:"setting-the-stack",level:3},{value:"Passing Parameters from C to the Assembly Procedure",id:"passing-parameters-from-c-to-the-assembly-procedure",level:3}],p={toc:m},c="wrapper";function u(e){let{components:n,...t}=e;return(0,i.yg)(c,(0,a.A)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"lab-10---the-c---assembly-interaction"},"Lab 10 - The C - Assembly Interaction"),(0,i.yg)("h2",{id:"task-maximum-calculation-in-assembly-with-call-from-c"},"Task: Maximum Calculation in Assembly with Call from C"),(0,i.yg)("p",null,"Navigate to ",(0,i.yg)("inlineCode",{parentName:"p"},"drills/tasks/max-c-calls/support")," and open ",(0,i.yg)("inlineCode",{parentName:"p"},"main.c")),(0,i.yg)("p",null,"In this subdirectory you can find an implementation of calculating the maximum of a number where the ",(0,i.yg)("inlineCode",{parentName:"p"},"main()")," function is defined in C from which the ",(0,i.yg)("inlineCode",{parentName:"p"},"get_max()")," function defined in assembly language is called."),(0,i.yg)("p",null,"Trace the code in the two files and how the function arguments and return value are passed."),(0,i.yg)("p",null,"Compile and run the program.\nTo compile it run the command:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},"make\n")),(0,i.yg)("p",null,"Then run the resulting executable:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-bash"},"./mainmax\n")),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"IMPORTANT:"),"\nPay attention to understanding the code before proceeding to the next exercise."),(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"IMPORTANT:"),"\nThe return value of a function is placed in the ",(0,i.yg)("inlineCode",{parentName:"p"},"eax")," register.")),(0,i.yg)("h3",{id:"maximum-computation-extension-in-assembly-with-call-from-c"},"Maximum Computation Extension in Assembly with Call from C"),(0,i.yg)("p",null,"Extend the program from the previous exercise (in assembly language and C) so that the ",(0,i.yg)("inlineCode",{parentName:"p"},"get_max()")," function now has the signature ",(0,i.yg)("inlineCode",{parentName:"p"},"unsigned int get_max(unsigned int *arr, unsigned int len, unsigned int *pos)"),".\nThe third argument to the function is the address where the position in the vector on which the maximum is found will be held."),(0,i.yg)("p",null,"The position in the vector on which the maximum is found will also be displayed on display."),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"TIP:"),"\nTo hold the position, it is best to define a local variable ",(0,i.yg)("inlineCode",{parentName:"p"},"pos")," in the ",(0,i.yg)("inlineCode",{parentName:"p"},"main()")," function in the C file (",(0,i.yg)("inlineCode",{parentName:"p"},"main.c"),") in the form"),(0,i.yg)("pre",{parentName:"blockquote"},(0,i.yg)("code",{parentName:"pre",className:"language-C"},"unsigned int pos;\n")),(0,i.yg)("p",{parentName:"blockquote"},"and call the ",(0,i.yg)("inlineCode",{parentName:"p"},"get_max()")," function in the form:"),(0,i.yg)("pre",{parentName:"blockquote"},(0,i.yg)("code",{parentName:"pre",className:"language-C"},"max = get_max(arr, 10, &pos);\n"))),(0,i.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,i.yg)("a",{parentName:"p",href:"/hardware-software-interface/Labs/lab10#c---assembly-interaction-stack"},"this relevant section")," reading material."),(0,i.yg)("h2",{id:"task-corrupt-stack-frame-debugging"},"Task: Corrupt Stack Frame Debugging"),(0,i.yg)("p",null,"Navigate to ",(0,i.yg)("inlineCode",{parentName:"p"},"drills/tasks/stack-frame/support")," and open ",(0,i.yg)("inlineCode",{parentName:"p"},"main.c")),(0,i.yg)("p",null,"In current subdirectory of the lab's task archive you can find a C program that implements the display of the string ",(0,i.yg)("inlineCode",{parentName:"p"},"Hello world!")," by a call to the ",(0,i.yg)("inlineCode",{parentName:"p"},"print_hello()")," function defined in the assembly for the first part of the message, followed by two calls to the ",(0,i.yg)("inlineCode",{parentName:"p"},"printf()")," function directly from the C code."),(0,i.yg)("p",null,"Compile and run the program.\nWhat do you notice?\nThe printed message is not as expected because the assembly code is missing an instruction."),(0,i.yg)("p",null,"Use GDB to inspect the address at the top of the stack before executing the ",(0,i.yg)("inlineCode",{parentName:"p"},"ret")," statement in the ",(0,i.yg)("inlineCode",{parentName:"p"},"print_hello()")," function.\nWhat does it point to?\nTrack the values of the ",(0,i.yg)("inlineCode",{parentName:"p"},"ebp")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"esp")," registers during the execution of this function.\nWhat should be at the top of the stack after execution of the ",(0,i.yg)("inlineCode",{parentName:"p"},"leave")," statement?"),(0,i.yg)("p",null,"Find the missing instruction and rerun the executable."),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"TIP:"),"\nIn order to restore the stack to its state at the start of the current function, the ",(0,i.yg)("inlineCode",{parentName:"p"},"leave")," statement relies on the function's pointer frame having been set.")),(0,i.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,i.yg)("a",{parentName:"p",href:"/hardware-software-interface/Labs/lab10#c---assembly-interaction-stack"},"this relevant section")," reading material."),(0,i.yg)("h2",{id:"task-maximum-calculation-in-c-with-call-from-assembly"},"Task: Maximum Calculation in C with Call from Assembly"),(0,i.yg)("p",null,"Navigate to ",(0,i.yg)("inlineCode",{parentName:"p"},"drills/tasks/max-assembly-calls/support/")," and open ",(0,i.yg)("inlineCode",{parentName:"p"},"main.asm")),(0,i.yg)("p",null,"In this directory you can find an implementation of calculating the maximum of a number where the ",(0,i.yg)("inlineCode",{parentName:"p"},"main()")," function is defined in assembly language from which the ",(0,i.yg)("inlineCode",{parentName:"p"},"get_max()")," function defined in C is called."),(0,i.yg)("p",null,"Trace the code in the two files and how the function arguments and return value are passed."),(0,i.yg)("p",null,"Compile and run the program."),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"IMPORTANT:"),"\nPay attention to understanding the code before proceeding to the next exercise.")),(0,i.yg)("h3",{id:"extending-maximum-computation-in-c-with-call-from-assembly"},"Extending Maximum Computation in C with Call from Assembly"),(0,i.yg)("p",null,"Extend the program from the previous exercise (in assembly language and C) so that the ",(0,i.yg)("inlineCode",{parentName:"p"},"get_max()")," function now has the signature ",(0,i.yg)("inlineCode",{parentName:"p"},"unsigned int get_max(unsigned int *arr, unsigned int len, unsigned int *pos)"),".\nThe third argument to the function is the address where the position in the vector on which the maximum is found will be held."),(0,i.yg)("p",null,"The position in the vector on which the maximum is found will also be displayed on display."),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"TIP:"),"\nTo hold the position, it is best to define a global variable in the assembly file (",(0,i.yg)("inlineCode",{parentName:"p"},"main.asm"),") in the ",(0,i.yg)("inlineCode",{parentName:"p"},".data")," section, of the form"),(0,i.yg)("pre",{parentName:"blockquote"},(0,i.yg)("code",{parentName:"pre",className:"language-Assembly"},"pos: dd 0\n")),(0,i.yg)("p",{parentName:"blockquote"},"This variable you will pass (by address) to the ",(0,i.yg)("inlineCode",{parentName:"p"},"get_max()")," call and by value to the ",(0,i.yg)("inlineCode",{parentName:"p"},"printf()")," call for display."),(0,i.yg)("p",{parentName:"blockquote"},"For display modify the ",(0,i.yg)("inlineCode",{parentName:"p"},"print_format")," string and the ",(0,i.yg)("inlineCode",{parentName:"p"},"printf()")," call in the assembly file (",(0,i.yg)("inlineCode",{parentName:"p"},"main.asm"),") to allow two values to be displayed: maximum and position.")),(0,i.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,i.yg)("a",{parentName:"p",href:"/hardware-software-interface/Labs/lab10#c---assembly-interaction-stack"},"this relevant section")," reading material."),(0,i.yg)("h2",{id:"task-keeping-records"},"Task: Keeping Records"),(0,i.yg)("p",null,"Navigate to ",(0,i.yg)("inlineCode",{parentName:"p"},"drills/tasks/regs-preserve/support")," and open ",(0,i.yg)("inlineCode",{parentName:"p"},"main.asm")),(0,i.yg)("p",null,"In this subdirectory of the lab's task repository you will find the ",(0,i.yg)("inlineCode",{parentName:"p"},"print_reverse_array()")," function implemented by a simple loop that makes repeated calls of the ",(0,i.yg)("inlineCode",{parentName:"p"},"printf()")," function."),(0,i.yg)("p",null,"Follow the code in the ",(0,i.yg)("inlineCode",{parentName:"p"},"main.asm")," file, compile and run the program.\nWhat happened?\nThe program runs indefinitely.\nThis is because the ",(0,i.yg)("inlineCode",{parentName:"p"},"printf()")," function does not preserve the value in the ",(0,i.yg)("inlineCode",{parentName:"p"},"ecx")," register, used here as a counter."),(0,i.yg)("p",null,"Uncomment the lines marked ",(0,i.yg)("inlineCode",{parentName:"p"},"TODO1")," and rerun the program."),(0,i.yg)("h3",{id:"troubleshooting-segfault"},"Troubleshooting SEGFAULT"),(0,i.yg)("p",null,"Decompose the lines marked ",(0,i.yg)("inlineCode",{parentName:"p"},"TODO2")," in the assembly file from the previous exercise.\nThe code sequence makes a call to the ",(0,i.yg)("inlineCode",{parentName:"p"},"double_array()")," function, implemented in C, just before displaying the vector using the function seen earlier."),(0,i.yg)("p",null,"Compile and run the program.\nTo debug the segfault you can use the ",(0,i.yg)("inlineCode",{parentName:"p"},"objdump")," utility to trace the assembly language code corresponding to the ",(0,i.yg)("inlineCode",{parentName:"p"},"double_array()")," function.\nNotice which of the registers used before and after the call are modified by this function."),(0,i.yg)("p",null,"Add the instructions for preserving and restoring the required registers to the assembly file."),(0,i.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,i.yg)("a",{parentName:"p",href:"/hardware-software-interface/Labs/lab10#c---assembly-interaction-memory-perspective"},"this relevant section")," reading material."),(0,i.yg)("h2",{id:"task-warning-not-an-error"},"Task: Warning (not an error)"),(0,i.yg)("p",null,"Access the directory ",(0,i.yg)("inlineCode",{parentName:"p"},"drills/tasks/include-fix/support/"),".\nRun the ",(0,i.yg)("inlineCode",{parentName:"p"},"make")," command.\nA warning appears, but it is from the preprocessing/compilation process.\nResolve this warning by editing the ",(0,i.yg)("inlineCode",{parentName:"p"},"hello.c")," file."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Bonus"),": Fix the warning without using the ",(0,i.yg)("inlineCode",{parentName:"p"},"#include")," directive."),(0,i.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,i.yg)("a",{parentName:"p",href:"/hardware-software-interface/Labs/lab12#linking"},"this")," reading material."),(0,i.yg)("h2",{id:"task-fixing-export-issues"},"Task: Fixing Export Issues"),(0,i.yg)("p",null,"Access the directory ",(0,i.yg)("inlineCode",{parentName:"p"},"drills/tasks/export-fix/support/"),".\nEach subdirectory (",(0,i.yg)("inlineCode",{parentName:"p"},"a-func/"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"b-var/"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"c-var-2/"),") contains a problem related to the export of symbols (functions or variables).\nIn each subdirectory, run the ",(0,i.yg)("inlineCode",{parentName:"p"},"make")," command, identify the issue, and edit the necessary files to resolve it."),(0,i.yg)("p",null,"If you're having difficulties solving this exercise, go through ",(0,i.yg)("a",{parentName:"p",href:"/hardware-software-interface/Labs/lab12#linking"},"this")," reading material."),(0,i.yg)("h2",{id:"task-maximum-computation-in-assembly-with-64-bit-c-call"},"Task: Maximum Computation in Assembly with 64-bit C Call"),(0,i.yg)("p",null,"Navigate to ",(0,i.yg)("inlineCode",{parentName:"p"},"drills/tasks/max-c-calls-x64/support")," and open ",(0,i.yg)("inlineCode",{parentName:"p"},"main.c")),(0,i.yg)("p",null,"In this subdirectory you should have implemented the maximum assembly language calculation on a 64-bit system.\nStart the program from exercises 4 and 5 in such a way that you run it using a 64-bit system."),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"TIP:"),"\n",(0,i.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/X86_calling_conventions"},"https://en.wikipedia.org/wiki/X86_calling_conventions"),"."),(0,i.yg)("p",{parentName:"blockquote"},"The first thing to note is that on the x64 architecture the registers are 8 bytes in size and have different names than the 32-bit ones (in addition to extending the traditional ones: ",(0,i.yg)("inlineCode",{parentName:"p"},"eax")," register becomes ",(0,i.yg)("inlineCode",{parentName:"p"},"rax"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"ebx")," register becomes ",(0,i.yg)("inlineCode",{parentName:"p"},"rbx"),", etc., there are new ones: R10-R15: for more information see ",(0,i.yg)("a",{parentName:"p",href:"https://stackoverflow.com/questions/20637569/assembly-registers-in-64-bit-architecture"},"here"),")."),(0,i.yg)("p",{parentName:"blockquote"},"Also, on x64 architecture parameters are no longer sent to the stack, but put in registers.\nThe first 3 parameters are put in: ",(0,i.yg)("inlineCode",{parentName:"p"},"rdi"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"rsi")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"rdx")," registers.\nThis is not a uniformly adopted convention.\nThis convention is only valid on Linux, on Windows there are other registers which are used to pass the parameters of a function.\nThe calling convention requires that, for functions with a variable number of arguments, ",(0,i.yg)("inlineCode",{parentName:"p"},"rax")," register be set to the number of vector registers used to pass arguments.\n",(0,i.yg)("inlineCode",{parentName:"p"},"printf()")," is a variable argument count function, and unless you use registers other than those mentioned in the previous paragraph for passing arguments, you must set ",(0,i.yg)("inlineCode",{parentName:"p"},"rax = 0")," before calling.\nRead more ",(0,i.yg)("a",{parentName:"p",href:"https://stackoverflow.com/questions/38335212/calling-printf-in-x86-64-using-gnu-assembler"},"here"),".")),(0,i.yg)("h2",{id:"task-bonus-maximum-calculation-in-c-with-call-from-assembly---64-bits"},"Task: Bonus: Maximum Calculation in C with Call from Assembly - 64 Bits"),(0,i.yg)("p",null,"Enter the directory ",(0,i.yg)("inlineCode",{parentName:"p"},"drills/tasks/max-assembly-calls-x64/support")," and implement the maximum calculation in C with a call from Assembly language on a 64-bit system.\nStart from the program used in ",(0,i.yg)("inlineCode",{parentName:"p"},"drills/tasks/max-assembly-calls"),", ensuring it runs on a 64-bit system.\nFollow the instructions from the previous exercise and pay attention to the order of parameters."),(0,i.yg)("h2",{id:"c---assembly-interaction-memory-perspective"},"C - Assembly Interaction: Memory Perspective"),(0,i.yg)("p",null,"Considering that assembly language poses challenges both in reading and in developing code, the general trend is to migrate towards high-level languages (which are much easier to read and provide a more user-friendly API).\nHowever, there are still situations where, for optimization reasons, small assembly routines are used and integrated into the high-level language module."),(0,i.yg)("p",null,"In this laboratory, we will explore how assembly modules can be integrated into C programs and vice versa."),(0,i.yg)("h3",{id:"using-assembly-procedures-in-c-functions"},"Using Assembly Procedures in C Functions"),(0,i.yg)("p",null,"Using assembly procedures in C functions for a C program to be executed, it must be translated into the machine code of the processor;\nthis is the task of a compiler.\nSince this compiled code is not always optimal, in some cases it is preferable to replace portions of code written in C with portions of assembly code that do the same thing, but with better performance."),(0,i.yg)("h4",{id:"declaration-of-the-procedure"},"Declaration of the Procedure"),(0,i.yg)("p",null,"In order to ensure that the assembly procedure and Module C are properly combined and compatible, the following steps must be followed:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"declare the procedure label as global, using the GLOBAL directive.\nIn addition to this, any data that will be used by the procedure must be declared as global.")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"using the ",(0,i.yg)("inlineCode",{parentName:"p"},"extern")," directive to declare procedures and global data as external."))),(0,i.yg)("h3",{id:"calling-c-functions-from-assembly-procedures"},"Calling C Functions from Assembly Procedures"),(0,i.yg)("p",null,"In most cases, calling routines or functions from the standard C library in an assembly language program is a much more complex operation than vice versa.\nTake the example of calling the ",(0,i.yg)("inlineCode",{parentName:"p"},"printf()")," function from an assembly language program:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-Assembly"},'global main\n\nexternal printf\n\nsection .data\n\ntext db "291 is the best!", 10, 0\nstrformat db "%s", 0\n\nsection .code\n\nmain:\n        push dword text\n        push dword strformat\n        call printf\n        add esp, 8\n        ret\n')),(0,i.yg)("p",null,"Note that the procedure is declared as global and is called ",(0,i.yg)("inlineCode",{parentName:"p"},"main")," - the starting point of any C program.\nSince in C the parameters are stacked in reverse order, the string offset is set first, followed by the format string offset.\nThe C function can be called afterwards, but the stack must be restored when the function exits."),(0,i.yg)("p",null,"When linking assembly code the standard C library (or the library containing the functions you use) must be included."),(0,i.yg)("h2",{id:"c---assembly-interaction-stack"},"C - Assembly Interaction: Stack"),(0,i.yg)("h3",{id:"setting-the-stack"},"Setting the Stack"),(0,i.yg)("p",null,"When entering a procedure, it is necessary to set a stack frame to which to send parameters.\nOf course, if the procedure does not receive parameters, this step is not necessary. So to set the stack, the following code must be included:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-Assembly"},"push ebp\nmov ebp, esp\n")),(0,i.yg)("p",null,"The EBP gives us the ability to use it as an index within the stack and should not be altered during the procedure."),(0,i.yg)("h3",{id:"passing-parameters-from-c-to-the-assembly-procedure"},"Passing Parameters from C to the Assembly Procedure"),(0,i.yg)("p",null,"C programs send parameters to assembly procedures using the stack.\nConsider the following C program sequence:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-C"},"##include <stdio.h>\n\nextern int sum(int a, int b);  // declare the assembly procedure as external\n\nint main() {\n    int a = 5, b = 7;\n    int res = sum(a, b);  // call the assembly procedure\n\n    return 0;\n}\n")),(0,i.yg)("p",null,"When C executes the call to ",(0,i.yg)("inlineCode",{parentName:"p"},"sum()"),", it first pushes arguments on the stack in reverse order, then actually calls the procedure.\nThus, upon entering the procedure body, the stack will be intact."),(0,i.yg)("p",null,"Since the variables ",(0,i.yg)("inlineCode",{parentName:"p"},"a")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"b")," are declared as ",(0,i.yg)("inlineCode",{parentName:"p"},"int")," values, they will each use one word on the stack.\nThis method of passing parameters is called value passing.\nThe code of the Sum procedure might look like this:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-Assembly"},"section .text\n    global sum   ; declare the procedure label as global\n\nsum:\n    push ebp\n    mov ebp, esp\n\n    mov eax, [ebp+8]     ; retrieve the first argument\n    mov ecx, [ebp+12]    ; retrieve the second argument\n    add eax, ecx         ; calculate the sum\n\n    pop ebp\n    ret\n")),(0,i.yg)("p",null,"It is interesting to note several things.\nFirst, the assembly code defaults the return value of the procedure to the ",(0,i.yg)("inlineCode",{parentName:"p"},"eax")," register.\nSecond, the ",(0,i.yg)("inlineCode",{parentName:"p"},"ret")," command is sufficient to exit the procedure, due to the fact that the C compiler takes care of the rest of the stuff, such as removing parameters from the stack."))}u.isMDXComponent=!0}}]);