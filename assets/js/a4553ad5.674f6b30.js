"use strict";(self.webpackChunkhardware_software_interface=self.webpackChunkhardware_software_interface||[]).push([[975],{5680:(e,n,t)=>{t.d(n,{xA:()=>g,yg:()=>u});var a=t(6540);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},g=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},h=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,g=o(e,["components","mdxType","originalType","parentName"]),c=p(t),h=i,u=c["".concat(s,".").concat(h)]||c[h]||m[h]||r;return t?a.createElement(u,l(l({ref:n},g),{},{components:t})):a.createElement(u,l({ref:n},g))}));function u(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,l=new Array(r);l[0]=h;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[c]="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=t[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},4973:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=t(8168),i=(t(6540),t(5680));const r={},l="Lab 9 - Functions",o={unversionedId:"Labs/lab9",id:"Labs/lab9",title:"Lab 9 - Functions",description:"Task: Displaying a String",source:"@site/docs/Labs/lab9.md",sourceDirName:"Labs",slug:"/Labs/lab9",permalink:"/hardware-software-interface/Labs/lab9",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Lab 8 - The Stack",permalink:"/hardware-software-interface/Labs/lab8"},next:{title:"Lab 10 - The C - Assembly Interaction",permalink:"/hardware-software-interface/Labs/lab10"}},s={},p=[{value:"Task: Displaying a String",id:"task-displaying-a-string",level:2},{value:"Task: Displaying the Length of a String",id:"task-displaying-the-length-of-a-string",level:2},{value:"Task: Displaying the Reversed String",id:"task-displaying-the-reversed-string",level:2},{value:"Task: Implementing the <code>toupper()</code> Function",id:"task-implementing-the-toupper-function",level:2},{value:"Bonus: <code>toupper()</code> Only for Lowercase Letters",id:"bonus-toupper-only-for-lowercase-letters",level:3},{value:"Task: Bonus: Rot13",id:"task-bonus-rot13",level:2},{value:"Bonus: Rot13++",id:"bonus-rot13",level:3},{value:"Functions",id:"functions",level:2},{value:"Passing Parameters",id:"passing-parameters",level:3},{value:"Function Call",id:"function-call",level:3},{value:"Stack Operation",id:"stack-operation",level:4},{value:"Caller and Callee",id:"caller-and-callee",level:3},{value:"Remarks",id:"remarks",level:4},{value:"Guide: Hello, World",id:"guide-hello-world",level:2},{value:"Guide: Disassembling a C program",id:"guide-disassembling-a-c-program",level:2}],g={toc:p},c="wrapper";function m(e){let{components:n,...r}=e;return(0,i.yg)(c,(0,a.A)({},g,r,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"lab-9---functions"},"Lab 9 - Functions"),(0,i.yg)("h2",{id:"task-displaying-a-string"},"Task: Displaying a String"),(0,i.yg)("p",null,"Navigate to ",(0,i.yg)("inlineCode",{parentName:"p"},"chapters/stack/functions/drills/tasks/string-print/support/"),"."),(0,i.yg)("p",null,"To display a string, we can use the internal macro ",(0,i.yg)("inlineCode",{parentName:"p"},"PRINTF32"),".\nAlternatively, we can use a function such as ",(0,i.yg)("inlineCode",{parentName:"p"},"puts()"),".\nIn the file ",(0,i.yg)("inlineCode",{parentName:"p"},"print_string.asm"),", displaying a string using the ",(0,i.yg)("inlineCode",{parentName:"p"},"PRINTF32")," macro is implemented."),(0,i.yg)("p",null,"Following the example of the ",(0,i.yg)("inlineCode",{parentName:"p"},"hello_world.asm")," file, implement string display using ",(0,i.yg)("inlineCode",{parentName:"p"},"puts")," as well."),(0,i.yg)("p",null,"If you're having difficulties solving this exercise, take a peek at ",(0,i.yg)("a",{parentName:"p",href:"guides/hello_world/"},"hello_world.asm"),"."),(0,i.yg)("p",null,"If you're having trouble solving this exercise, go through ",(0,i.yg)("a",{parentName:"p",href:"/hardware-software-interface/Labs/lab9#functions"},"this")," reading material."),(0,i.yg)("h2",{id:"task-displaying-the-length-of-a-string"},"Task: Displaying the Length of a String"),(0,i.yg)("p",null,"Navigate to ",(0,i.yg)("inlineCode",{parentName:"p"},"chapters/stack/functions/drills/tasks/string-print-len/support/"),"."),(0,i.yg)("p",null,"The program ",(0,i.yg)("inlineCode",{parentName:"p"},"print_string_len.asm")," displays the length of a string using the ",(0,i.yg)("inlineCode",{parentName:"p"},"PRINTF32")," macro.\nThe calculation of the length of the ",(0,i.yg)("inlineCode",{parentName:"p"},"mystring")," string occurs within the program (it is already implemented)."),(0,i.yg)("p",null,"Implement the program to display the length of the string using the ",(0,i.yg)("inlineCode",{parentName:"p"},"printf")," function."),(0,i.yg)("p",null,"At the end, you will have the length of the string displayed twice: initially with the ",(0,i.yg)("inlineCode",{parentName:"p"},"PRINTF32")," macro and then with the external function call ",(0,i.yg)("inlineCode",{parentName:"p"},"printf"),"."),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"NOTE:"),"  Consider that the ",(0,i.yg)("inlineCode",{parentName:"p"},"printf")," call is of the form ",(0,i.yg)("inlineCode",{parentName:"p"},'printf("String length is %u\\n", len);'),".\nYou need to construct the stack for this call."),(0,i.yg)("p",{parentName:"blockquote"},"The steps to follow are:"),(0,i.yg)("ol",{parentName:"blockquote"},(0,i.yg)("li",{parentName:"ol"},"Mark the symbol ",(0,i.yg)("inlineCode",{parentName:"li"},"printf")," as external."),(0,i.yg)("li",{parentName:"ol"},"Define the format string ",(0,i.yg)("inlineCode",{parentName:"li"},'"String length is %u", 10, 0'),"."),(0,i.yg)("li",{parentName:"ol"},"Make the function call to ",(0,i.yg)("inlineCode",{parentName:"li"},"printf"),", i.e.:",(0,i.yg)("ol",{parentName:"li"},(0,i.yg)("li",{parentName:"ol"},"Put the two arguments on the stack: the format string and the length."),(0,i.yg)("li",{parentName:"ol"},"Call ",(0,i.yg)("inlineCode",{parentName:"li"},"printf")," using ",(0,i.yg)("inlineCode",{parentName:"li"},"call"),"."),(0,i.yg)("li",{parentName:"ol"},"Restore the stack.")))),(0,i.yg)("p",{parentName:"blockquote"},"The length of the string is found in the ",(0,i.yg)("inlineCode",{parentName:"p"},"ecx")," register.")),(0,i.yg)("p",null,"If you're having trouble solving this exercise, go through ",(0,i.yg)("a",{parentName:"p",href:"/hardware-software-interface/Labs/lab9#functions"},"this")," reading material."),(0,i.yg)("h2",{id:"task-displaying-the-reversed-string"},"Task: Displaying the Reversed String"),(0,i.yg)("p",null,"Navigate to ",(0,i.yg)("inlineCode",{parentName:"p"},"chapters/stack/functions/drills/tasks/print-rev-string/support/"),"."),(0,i.yg)("p",null,"In the file ",(0,i.yg)("inlineCode",{parentName:"p"},"print_rev_string.asm"),", add the ",(0,i.yg)("inlineCode",{parentName:"p"},"reverse_string()")," function so that you have a listing similar to the one below:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-Assembly"},"[...]\nsection .text\nglobal main\n\nreverse_string:\n    push ebp\n    mov ebp, esp\n\n    mov eax, [ebp + 8]\n    mov ecx, [ebp + 12]\n    add eax, ecx\n    dec eax\n    mov edx, [ebp + 16]\n\ncopy_one_byte:\n    mov bl, [eax]\n    mov [edx], bl\n    dec eax\n    inc edx\n    loopnz copy_one_byte\n\n    inc edx\n    mov byte [edx], 0\n\n    leave\n    ret\n\nmain:\n    push ebp\n    mov ebp, esp\n[...]\n")),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"IMPORTANT:"),"  When copying the ",(0,i.yg)("inlineCode",{parentName:"p"},"reverse_string()")," function into your program, remember that the function starts at the ",(0,i.yg)("inlineCode",{parentName:"p"},"reverse_string()")," label and ends at the ",(0,i.yg)("inlineCode",{parentName:"p"},"main")," label.\nThe ",(0,i.yg)("inlineCode",{parentName:"p"},"copy_one_byte")," label is part of the ",(0,i.yg)("inlineCode",{parentName:"p"},"reverse_string()")," function.")),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"reverse_string()")," function reverses a string and has the following signature: ",(0,i.yg)("inlineCode",{parentName:"p"},"void reverse_string(const char *src, size_t len, char *dst);"),".\nThis means that the first ",(0,i.yg)("inlineCode",{parentName:"p"},"len")," characters of the ",(0,i.yg)("inlineCode",{parentName:"p"},"src")," string are reversed into the ",(0,i.yg)("inlineCode",{parentName:"p"},"dst")," string."),(0,i.yg)("p",null,"Reverse the ",(0,i.yg)("inlineCode",{parentName:"p"},"mystring")," string into a new string and display that new string."),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"NOTE:"),"  To define a new string, we recommend using the following construction in the data section:"),(0,i.yg)("pre",{parentName:"blockquote"},(0,i.yg)("code",{parentName:"pre",className:"language-Assembly"},"store_string times 64 db 0\n")),(0,i.yg)("p",{parentName:"blockquote"},"This creates a string of 64 zero bytes, enough to store the reverse of the string.\nThe equivalent C function call is ",(0,i.yg)("inlineCode",{parentName:"p"},"reverse_string(mystring, ecx, store_string);"),".\nWe assume that the length of the string is calculated and stored in the ",(0,i.yg)("inlineCode",{parentName:"p"},"ecx")," register."),(0,i.yg)("p",{parentName:"blockquote"},"You cannot directly use the value of ",(0,i.yg)("inlineCode",{parentName:"p"},"ecx")," in its current form.\nAfter the ",(0,i.yg)("inlineCode",{parentName:"p"},"printf()")," function call for displaying the length, the value of ",(0,i.yg)("inlineCode",{parentName:"p"},"ecx")," is not preserved.\nTo retain it, you have two options:"),(0,i.yg)("ol",{parentName:"blockquote"},(0,i.yg)("li",{parentName:"ol"},"Store the value of the ",(0,i.yg)("inlineCode",{parentName:"li"},"ecx")," register on the stack beforehand (using ",(0,i.yg)("inlineCode",{parentName:"li"},"push ecx")," before the ",(0,i.yg)("inlineCode",{parentName:"li"},"printf")," call) and then restore it after the ",(0,i.yg)("inlineCode",{parentName:"li"},"printf")," call (using ",(0,i.yg)("inlineCode",{parentName:"li"},"pop ecx"),")."),(0,i.yg)("li",{parentName:"ol"},"Store the value of the ",(0,i.yg)("inlineCode",{parentName:"li"},"ecx")," register in a global variable, which you define in the ",(0,i.yg)("inlineCode",{parentName:"li"},".data")," section.")),(0,i.yg)("p",{parentName:"blockquote"},"You cannot use another register because there is a high chance that even that register will be modified by the ",(0,i.yg)("inlineCode",{parentName:"p"},"printf")," call to display the length of the string.")),(0,i.yg)("p",null,"If you're having trouble solving this exercise, go through ",(0,i.yg)("a",{parentName:"p",href:"/hardware-software-interface/Labs/lab9#functions"},"this")," reading material."),(0,i.yg)("h2",{id:"task-implementing-the-toupper-function"},"Task: Implementing the ",(0,i.yg)("inlineCode",{parentName:"h2"},"toupper()")," Function"),(0,i.yg)("p",null,"Navigate to ",(0,i.yg)("inlineCode",{parentName:"p"},"chapters/stack/functions/drills/tasks/to-upper/support/"),"."),(0,i.yg)("p",null,"We aim to implement the ",(0,i.yg)("inlineCode",{parentName:"p"},"toupper()")," function, which converts lowercase letters to uppercase.\nTo do this, start with the ",(0,i.yg)("inlineCode",{parentName:"p"},"to_upper.asm")," file from the lab exercises archive and complete the body of the ",(0,i.yg)("inlineCode",{parentName:"p"},"toupper()")," function."),(0,i.yg)("p",null,"The string used is ",(0,i.yg)("inlineCode",{parentName:"p"},"mystring"),", and we assume it is a valid string.\nThis string is passed as an argument to the ",(0,i.yg)("inlineCode",{parentName:"p"},"toupper()")," function when called."),(0,i.yg)("p",null,"Perform the transformation in place;\nthere is no need for another string."),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"NOTE_"),"  To convert a lowercase letter to uppercase, you need to ",(0,i.yg)("strong",{parentName:"p"},"subtract")," ",(0,i.yg)("inlineCode",{parentName:"p"},"0x20")," from its value.\nThis is the difference between lowercase and uppercase letters;\nfor example, ",(0,i.yg)("inlineCode",{parentName:"p"},"a")," is ",(0,i.yg)("inlineCode",{parentName:"p"},"0x61"),", and ",(0,i.yg)("inlineCode",{parentName:"p"},"A")," is ",(0,i.yg)("inlineCode",{parentName:"p"},"0x41"),".\nYou can see this in the ",(0,i.yg)("a",{parentName:"p",href:"http://man7.org/linux/man-pages/man7/ascii.7.html"},"ASCII manual page"),"."),(0,i.yg)("p",{parentName:"blockquote"},"To read or write byte by byte, use the ",(0,i.yg)("inlineCode",{parentName:"p"},"byte [reg]")," construction as seen in the implementation of determining the length of a string in the ",(0,i.yg)("inlineCode",{parentName:"p"},"print_string_length.asm")," file, where ",(0,i.yg)("inlineCode",{parentName:"p"},"[reg]")," is the pointer register storing the address of the string at that point."),(0,i.yg)("p",{parentName:"blockquote"},"Stop when you reach the value ",(0,i.yg)("inlineCode",{parentName:"p"},"0")," (",(0,i.yg)("inlineCode",{parentName:"p"},"NULL")," byte).\nFor checking, you can use ",(0,i.yg)("inlineCode",{parentName:"p"},"test")," as seen in the implementation of determining the length of a string in the ",(0,i.yg)("inlineCode",{parentName:"p"},"print-string-length.asm")," file.")),(0,i.yg)("h3",{id:"bonus-toupper-only-for-lowercase-letters"},"Bonus: ",(0,i.yg)("inlineCode",{parentName:"h3"},"toupper()")," Only for Lowercase Letters"),(0,i.yg)("p",null,"Implement the ",(0,i.yg)("inlineCode",{parentName:"p"},"toupper()")," function so that the transformation occurs only for lowercase characters, not uppercase letters or other types of characters."),(0,i.yg)("p",null,"If you're having trouble solving this exercise, go through ",(0,i.yg)("a",{parentName:"p",href:"/hardware-software-interface/Labs/lab9#functions"},"this")," reading material."),(0,i.yg)("h2",{id:"task-bonus-rot13"},"Task: Bonus: Rot13"),(0,i.yg)("p",null,"Navigate to ",(0,i.yg)("inlineCode",{parentName:"p"},"chapters/stack/functions/drills/tasks/rot13/support/"),"."),(0,i.yg)("p",null,"Create and use a function that performs ",(0,i.yg)("a",{parentName:"p",href:"https://rot13.com/"},"rot13")," translation of a string."),(0,i.yg)("h3",{id:"bonus-rot13"},"Bonus: Rot13++"),(0,i.yg)("p",null,"Implement ",(0,i.yg)("inlineCode",{parentName:"p"},"rot13")," on an array of strings: the strings are contiguous in memory separated by the string terminator (",(0,i.yg)("inlineCode",{parentName:"p"},"NULL"),"-byte, ",(0,i.yg)("inlineCode",{parentName:"p"},"0"),").\nFor example, ",(0,i.yg)("inlineCode",{parentName:"p"},"lorem\\0ipsum\\0dolor\\0")," is an array of three strings."),(0,i.yg)("p",null,"Apply ",(0,i.yg)("inlineCode",{parentName:"p"},"rot13")," to alphabetical characters and replace the string terminator with a space (",(0,i.yg)("inlineCode",{parentName:"p"},"' '"),", blank, character ",(0,i.yg)("inlineCode",{parentName:"p"},"32"),", or ",(0,i.yg)("inlineCode",{parentName:"p"},"0x20"),").\nThus, the initial string ",(0,i.yg)("inlineCode",{parentName:"p"},"lorem\\0ipsum\\0dolor\\0")," will translate to ",(0,i.yg)("inlineCode",{parentName:"p"},"yberz vcfhz qbybe"),"."),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"NOTE:")," To define the array of strings containing the string terminator, use a construction like:"),(0,i.yg)("pre",{parentName:"blockquote"},(0,i.yg)("code",{parentName:"pre",className:"language-Assembly"},'mystring db "lorem", 0, "ipsum", 0, "dolor", 0\n')),(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"NOTE:")," You will need to know when to stop traversing the array of strings. The simplest way is to define a length variable in the ",(0,i.yg)("inlineCode",{parentName:"p"},".data")," section, like so:"),(0,i.yg)("pre",{parentName:"blockquote"},(0,i.yg)("code",{parentName:"pre",className:"language-Assembly"},"len dd 10\n")),(0,i.yg)("p",{parentName:"blockquote"},"where you either store the total length of the string (from the beginning to the last ",(0,i.yg)("inlineCode",{parentName:"p"},"NULL")," byte) or the number of strings in the array.")),(0,i.yg)("p",null,"If you're having trouble solving this exercise, go through ",(0,i.yg)("a",{parentName:"p",href:"/hardware-software-interface/Labs/lab9#functions"},"this")," reading material."),(0,i.yg)("h2",{id:"functions"},"Functions"),(0,i.yg)("p",null,"In this lab, we'll discuss how function calls are performed.\nWe'll see how we can use the ",(0,i.yg)("inlineCode",{parentName:"p"},"call")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"ret")," instructions to make function calls and how we use the stack to pass function parameters."),(0,i.yg)("h3",{id:"passing-parameters"},"Passing Parameters"),(0,i.yg)("p",null,"When it comes to calling a function with parameters, there are two major options for placing them:"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("strong",{parentName:"p"},"Register Passing")," - this method intuitively involves passing parameters through registers."),(0,i.yg)("p",{parentName:"li"},"Advantages:"),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"It is very easy to use when the number of parameters is small."),(0,i.yg)("li",{parentName:"ul"},"It is very fast since parameters are immediately accessible from registers.")),(0,i.yg)("p",{parentName:"li"},"Disadvantages:"),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Because there is a limited number of registers, the number of parameters for a function becomes limited."),(0,i.yg)("li",{parentName:"ul"},"It's very likely that some registers are used inside the called function, and it becomes necessary to temporarily save registers on the stack before the function call.\nThus, the second advantage listed disappears because accessing the stack involves working with memory, meaning increased latency."))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},(0,i.yg)("strong",{parentName:"p"},"Stack Passing")," - this method involves pushing all parameters onto the stack."),(0,i.yg)("p",{parentName:"li"},"Advantages:"),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"A large number of parameters can be passed.")),(0,i.yg)("p",{parentName:"li"},"Disadvantages:"),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"It's slow because it involves memory access."),(0,i.yg)("li",{parentName:"ul"},"More complicated in terms of parameter access.")))),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"NOTE:")," For ",(0,i.yg)("strong",{parentName:"p"},"32-bit")," architectures, the stack passing method is used, while for ",(0,i.yg)("strong",{parentName:"p"},"64-bit")," architectures, the register passing method is used for the first 6 arguments.\nStarting from the 7th, the stack has to be used.\nWe will use the convention for 32-bit architecture.")),(0,i.yg)("h3",{id:"function-call"},"Function Call"),(0,i.yg)("p",null,"When we call a function, the steps are as follows:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"We put the arguments on the stack, pushing them in the reverse order in which they are sent as function arguments."),(0,i.yg)("li",{parentName:"ul"},"We call ",(0,i.yg)("inlineCode",{parentName:"li"},"call"),"."),(0,i.yg)("li",{parentName:"ul"},"We restore the stack at the end of the call.")),(0,i.yg)("h4",{id:"stack-operation"},"Stack Operation"),(0,i.yg)("p",null,"As we know, stack operations fall into two types:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"push val")," where the value ",(0,i.yg)("inlineCode",{parentName:"li"},"val")," is placed on the stack"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"pop reg/mem")," where what is on the top of the stack is placed into a register or memory area")),(0,i.yg)("p",null,"When we ",(0,i.yg)("inlineCode",{parentName:"p"},"push"),", we say that the stack ",(0,i.yg)("strong",{parentName:"p"},"grows")," (elements are added).\nFor reasons that will be better explained later, the stack pointer (indicated by the ",(0,i.yg)("inlineCode",{parentName:"p"},"esp")," register in 32-bit mode) decreases in value when the stack grows (on ",(0,i.yg)("inlineCode",{parentName:"p"},"push"),").\nHowever, this contradiction in naming comes from the fact that the stack is typically represented vertically, with smaller values at the top and larger values at the bottom."),(0,i.yg)("p",null,"Similarly, when we ",(0,i.yg)("inlineCode",{parentName:"p"},"pop"),", we say that the stack ",(0,i.yg)("strong",{parentName:"p"},"shrinks")," (elements are removed).\nNow the stack pointer (indicated by the ",(0,i.yg)("inlineCode",{parentName:"p"},"esp")," register in 32-bit mode) increases in value."),(0,i.yg)("p",null,"A summary of this is explained very well ",(0,i.yg)("a",{parentName:"p",href:"https://en.wikibooks.org/wiki/X86_Disassembly/The_Stack"},"here"),"."),(0,i.yg)("p",null,"For example, if we have the function ",(0,i.yg)("inlineCode",{parentName:"p"},"foo")," with the following signature (in C language):"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-C"},"int foo(int a, int b, int c);\n")),(0,i.yg)("p",null,"The call to this function will look like this:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-Assembly"},"mov ecx, [c]     ; take the value of parameter c from a memory location\nmov ebx, [b]\nmov eax, [a]\n\npush ecx         ; put parameters in reverse order, starting with c\npush ebx         ; then b\npush eax         ; then a\ncall foo         ; call the function\nadd esp, 12      ; restore the stack\n")),(0,i.yg)("h3",{id:"caller-and-callee"},"Caller and Callee"),(0,i.yg)("p",null,"When we call a function, we say that the calling function (the context that calls) is the ",(0,i.yg)("strong",{parentName:"p"},"caller"),", while the called function is the ",(0,i.yg)("strong",{parentName:"p"},"callee"),".\nIn the previous paragraph, we discussed how things look at the caller level (how we build the stack)."),(0,i.yg)("p",null,"Now let's see what happens at the callee level.\nUntil the ",(0,i.yg)("inlineCode",{parentName:"p"},"call")," instruction, the stack contains the function's parameters.\nThe ",(0,i.yg)("inlineCode",{parentName:"p"},"call")," can be roughly equated to the following sequence:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-Assembly"},"push eip\njmp function_name\n")),(0,i.yg)("p",null,"That is, even the ",(0,i.yg)("inlineCode",{parentName:"p"},"call")," uses the stack and saves the address of the next instruction, the one after the ",(0,i.yg)("inlineCode",{parentName:"p"},"call"),", also known as the ",(0,i.yg)("strong",{parentName:"p"},"return address"),".\nThis is necessary for the callee to know where to return to in the caller."),(0,i.yg)("p",null,"In the callee, at its beginning (called preamble), the frame pointer is saved (in the i386 architecture, this is the ",(0,i.yg)("inlineCode",{parentName:"p"},"ebp")," register), with the frame pointer then referring to the current function stack frame.\nThis is crucial for accessing parameters and local variables via an offset from the frame pointer."),(0,i.yg)("p",null,"Although not mandatory, saving the frame pointer helps in debugging and is used in most cases.\nFor these reasons, any function call will generally have a preamble:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-Assembly"},"push ebp\nmov ebp, esp\n")),(0,i.yg)("p",null,"These modifications take place in the callee.\nTherefore, it is the responsibility of the callee to restore the stack to its old value.\nHence, it is customary to have an epilogue that restores the stack to its initial state; this epilogue is:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-Assembly"},"leave\n")),(0,i.yg)("p",null,"After this instruction, the stack is as it was at the beginning of the function (immediately after the call).\nIt is equivalent to the following code, which undoes the functions's preamble:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-Assembly"},"mov esp, ebp\npop ebp\n")),(0,i.yg)("p",null,"To conclude the function, it is necessary for the execution to return and continue from the instruction following the ",(0,i.yg)("inlineCode",{parentName:"p"},"call")," that started the function.\nThis involves influencing the ",(0,i.yg)("inlineCode",{parentName:"p"},"eip")," register and putting back the value that was saved on the stack initially by the ",(0,i.yg)("inlineCode",{parentName:"p"},"call")," instruction.\nThis is achieved using the instruction:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-Assembly"},"ret\n")),(0,i.yg)("p",null,"which is roughly equivalent to the instruction:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-Assembly"},"pop eip\n")),(0,i.yg)("p",null,"For example, the definition and body of the function foo, which calculates the sum of 3 numbers, would look like this:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-Assembly"},"\nfoo:\n    push ebp\n    mov ebp, esp\n\n    mov eax, [ebp + 8]\n    mov ebx, [ebp + 12]\n    mov ecx, [ebp + 16]\n\n    add eax, ebx\n    add eax, ecx\n\n    leave\n    ret\n")),(0,i.yg)("h4",{id:"remarks"},"Remarks"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"A function is defined by a label.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"After the function's preamble, the stack looks as follows:"),(0,i.yg)("p",{parentName:"li"},(0,i.yg)("img",{alt:"stack.svg",src:t(2027).A}))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Note that during the execution of the function, what does not change is the position of the frame pointer.\nThis is the reason for its name: it points to the current function's frame.\nTherefore, it is common to access a function's parameters through the frame pointer.\nAssuming a 32-bit system and processor word-sized parameters (32 bits, 4 bytes), we will have:"),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"the first argument is found at address ",(0,i.yg)("inlineCode",{parentName:"p"},"ebp+8"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"the second argument is found at address ",(0,i.yg)("inlineCode",{parentName:"p"},"ebp+12"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"the third argument is found at address ",(0,i.yg)("inlineCode",{parentName:"p"},"ebp+16"))),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"etc."),(0,i.yg)("p",{parentName:"li"},"This is why, to get the parameters of the foo function in the eax, ebx, ecx registers, we use the constructions:"),(0,i.yg)("pre",{parentName:"li"},(0,i.yg)("code",{parentName:"pre",className:"language-Assembly"},"mov eax, dword [ebp+8]   ; first argument in eax\nmov ebx, dword [ebp+12]  ; second argument in ebx\nmov ecx, dword [ebp+16]  ; third argument in ecx\n"))))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"The return value of a function is placed in registers (generally in eax)."),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"If the return value is ",(0,i.yg)("strong",{parentName:"p"},"8 bits"),", the function's result is placed in ",(0,i.yg)("inlineCode",{parentName:"p"},"al"),".")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"If the return value is ",(0,i.yg)("strong",{parentName:"p"},"16 bits"),", the function's result is placed in ",(0,i.yg)("inlineCode",{parentName:"p"},"ax"),".")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"If the return value is ",(0,i.yg)("strong",{parentName:"p"},"32 bits"),", the function's result is placed in ",(0,i.yg)("inlineCode",{parentName:"p"},"eax"),".")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("p",{parentName:"li"},"If the return value is ",(0,i.yg)("strong",{parentName:"p"},"64 bits"),", the result is placed in the ",(0,i.yg)("inlineCode",{parentName:"p"},"edx")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"eax")," registers.\nThe most significant 32 bits are placed in ",(0,i.yg)("inlineCode",{parentName:"p"},"edx"),", and the rest in the ",(0,i.yg)("inlineCode",{parentName:"p"},"eax")," register."),(0,i.yg)("p",{parentName:"li"},(0,i.yg)("em",{parentName:"p"},"Additionally, in some cases, a memory address can be returned to the stack/heap (e.g. ",(0,i.yg)("inlineCode",{parentName:"em"},"malloc()"),"), or other memory areas, which refer to the desired object after the function call."))))),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"A function uses the same hardware registers;\ntherefore, when exiting the function, the values of the registers are no longer the same.\nTo avoid this situation, some/all registers can be saved on the stack.\nYou can push all registers to the stack using the ",(0,i.yg)("a",{parentName:"p",href:"https://c9x.me/x86/html/file_module_x86_id_270.html"},(0,i.yg)("inlineCode",{parentName:"a"},"pusha"),' instruction - "push all"'),".\nAnd you can pop them all in the same order using ",(0,i.yg)("a",{parentName:"p",href:"https://c9x.me/x86/html/file_module_x86_id_249.html"},(0,i.yg)("inlineCode",{parentName:"a"},"popa")),".\nThe disadvantage of doing so is that writing all registers to the stack is going to be slower than only explicitly saving the registers used by the function.\nFor this reason, the ",(0,i.yg)("inlineCode",{parentName:"p"},"cdecl")," calling convention specifies that functions are allowed to change the values of the ",(0,i.yg)("inlineCode",{parentName:"p"},"eax"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"ecx")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"edx")," registers."))),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"NOTE:"),"  Since assembly languages offer more opportunities, there is a need for calling conventions in x86.\nThe difference between them may consist of the parameter order, how the parameters are passed to the function, which registers need to be preserved by the callee or whether the caller or callee handles stack preparation.\nMore details can be found ",(0,i.yg)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/X86_calling_conventions"},"here")," or ",(0,i.yg)("a",{parentName:"p",href:"https://levelup.gitconnected.com/x86-calling-conventions-a34812afe097"},"here")," if Wikipedia is too mainstream for you.\nFor us, the registers ",(0,i.yg)("inlineCode",{parentName:"p"},"eax"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"ecx"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"edx")," are considered ",(0,i.yg)("strong",{parentName:"p"},"clobbered")," (or volatile), and the callee can do whatever it wants to them.\nOn the other hand, the callee has to ensure that ",(0,i.yg)("inlineCode",{parentName:"p"},"ebx")," exits the function with the same value it has entered with.")),(0,i.yg)("h2",{id:"guide-hello-world"},"Guide: Hello, World"),(0,i.yg)("p",null,"Navigate to ",(0,i.yg)("inlineCode",{parentName:"p"},"chapters/stack/functions/guides/hello-world/support/"),"."),(0,i.yg)("p",null,"Open the ",(0,i.yg)("inlineCode",{parentName:"p"},"hello_world.asm")," file, assemble it, and run it.\nNotice the display of the message ",(0,i.yg)("em",{parentName:"p"},"Hello, world!")),(0,i.yg)("p",null,"Note that:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"The ",(0,i.yg)("inlineCode",{parentName:"li"},"hello_world.asm")," program uses the ",(0,i.yg)("inlineCode",{parentName:"li"},"puts()")," function call (an external function of the current module) to perform the display.\nFor this, it puts the argument on the stack and calls the function."),(0,i.yg)("li",{parentName:"ul"},"The ",(0,i.yg)("inlineCode",{parentName:"li"},"msg")," variable in the ",(0,i.yg)("inlineCode",{parentName:"li"},"hello_world.asm")," program contains the byte ",(0,i.yg)("inlineCode",{parentName:"li"},"10"),".\nThis symbolizes the ",(0,i.yg)("em",{parentName:"li"},"line feed")," character (",(0,i.yg)("inlineCode",{parentName:"li"},"\\n"),"), used to add a new line on Linux.")),(0,i.yg)("p",null,"Ending with ",(0,i.yg)("inlineCode",{parentName:"p"},"\\n")," is generally useful for displaying strings.\nThe ",(0,i.yg)("inlineCode",{parentName:"p"},"puts()")," function automatically adds a new line after the displayed string, but this must be explicitly added when using the ",(0,i.yg)("inlineCode",{parentName:"p"},"printf()")," function."),(0,i.yg)("h2",{id:"guide-disassembling-a-c-program"},"Guide: Disassembling a C program"),(0,i.yg)("p",null,"Navigate to ",(0,i.yg)("inlineCode",{parentName:"p"},"chapters/stack/functions/guides/disassembling-c/support/"),"."),(0,i.yg)("p",null,"As mentioned, ultimately everything ends up in assembly language (to be 100% accurate, everything ends up as machine code, which has a fairly good correspondence with assembly code).\nOften, we find ourselves with access only to the object code of some programs and we want to inspect how it looks."),(0,i.yg)("p",null,"To observe this, let's compile a C program to its object code and then disassemble it.\nWe'll use the ",(0,i.yg)("inlineCode",{parentName:"p"},"test.c")," program from the lab archive."),(0,i.yg)("blockquote",null,(0,i.yg)("p",{parentName:"blockquote"},(0,i.yg)("strong",{parentName:"p"},"NOTE:")," To compile a C/C++ source file in the command-line, follow these steps:")),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Open a terminal.\n(shortcut ",(0,i.yg)("inlineCode",{parentName:"p"},"Ctrl+Alt+T"),")")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Navigate to the directory containing your source code.")),(0,i.yg)("li",{parentName:"ol"},(0,i.yg)("p",{parentName:"li"},"Use the command:"))),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-Bash"},"gcc -m32 -o <exec> <sourcefile>\n")),(0,i.yg)("p",null,"where ",(0,i.yg)("inlineCode",{parentName:"p"},"<sourcefile>")," is the name of the source file (",(0,i.yg)("inlineCode",{parentName:"p"},"test.c"),") and ",(0,i.yg)("inlineCode",{parentName:"p"},"<exec>")," is the name of the result executable."),(0,i.yg)("p",null,"If you ",(0,i.yg)("strong",{parentName:"p"},"only")," want to compile (",(0,i.yg)("strong",{parentName:"p"},"without")," linking it), use:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-Bash"},"gcc -m32 -c -o <objfile> <sourcefile>\n")),(0,i.yg)("p",null,"where ",(0,i.yg)("inlineCode",{parentName:"p"},"<sourcefile>")," is the name of the source file and ",(0,i.yg)("inlineCode",{parentName:"p"},"<objfile>")," is the name of the desired output object file."),(0,i.yg)("p",null,"Since we want to transform ",(0,i.yg)("inlineCode",{parentName:"p"},"test.c")," into an object file, we'll run:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-Bash"},"gcc -m32 -c -o test.o test.c\n")),(0,i.yg)("p",null,"After running the above command, we should see a file named ",(0,i.yg)("inlineCode",{parentName:"p"},"test.o"),"."),(0,i.yg)("p",null,"Furthermore, we can use ",(0,i.yg)("inlineCode",{parentName:"p"},"gcc")," to transform the ",(0,i.yg)("inlineCode",{parentName:"p"},"C")," code in ",(0,i.yg)("inlineCode",{parentName:"p"},"Assembly")," code:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-Bash"},"gcc -m32 -masm=intel -S -o test.asm test.c\n")),(0,i.yg)("p",null,"After running the above command we'll have a file called ",(0,i.yg)("inlineCode",{parentName:"p"},"test.asm"),", which we can inspect using any text editor/reader, such as cat:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-Bash"},"cat test.asm\n")),(0,i.yg)("p",null,"In order to disassembly the code of an object file we'll use ",(0,i.yg)("inlineCode",{parentName:"p"},"objdump")," as follows:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-Bash"},"objdump -M intel -d <path-to-obj-file>\n")),(0,i.yg)("p",null,"where ",(0,i.yg)("inlineCode",{parentName:"p"},"<path-to-obj-file>")," is the path to the object file ",(0,i.yg)("inlineCode",{parentName:"p"},"test.o"),"."),(0,i.yg)("p",null,"Afterwards, you'll see an output similar to the following:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-console"},"$ objdump -M intel -d test.o\n\ntest.o:     file format elf32-i386\n\n\nDisassembly of section .text:\n\n00000000 <second_func>:\n   0:   55                      push   ebp\n   1:   89 e5                   mov    ebp,esp\n   3:   e8 fc ff ff ff          call   4 <second_func+0x4>\n   8:   05 01 00 00 00          add    eax,0x1\n   d:   8b 45 08                mov    eax,DWORD PTR [ebp+0x8]\n  10:   8b 10                   mov    edx,DWORD PTR [eax]\n  12:   8b 45 0c                mov    eax,DWORD PTR [ebp+0xc]\n  15:   01 c2                   add    edx,eax\n  17:   8b 45 08                mov    eax,DWORD PTR [ebp+0x8]\n  1a:   89 10                   mov    DWORD PTR [eax],edx\n  1c:   90                      nop\n  1d:   5d                      pop    ebp\n  1e:   c3                      ret\n\n0000001f <first_func>:\n  1f:   55                      push   ebp\n  20:   89 e5                   mov    ebp,esp\n  22:   53                      push   ebx\n  23:   83 ec 14                sub    esp,0x14\n  26:   e8 fc ff ff ff          call   27 <first_func+0x8>\n  2b:   05 01 00 00 00          add    eax,0x1\n  30:   c7 45 f4 03 00 00 00    mov    DWORD PTR [ebp-0xc],0x3\n  37:   83 ec 0c                sub    esp,0xc\n  3a:   8d 90 00 00 00 00       lea    edx,[eax+0x0]\n  40:   52                      push   edx\n  41:   89 c3                   mov    ebx,eax\n  43:   e8 fc ff ff ff          call   44 <first_func+0x25>\n  48:   83 c4 10                add    esp,0x10\n  4b:   83 ec 08                sub    esp,0x8\n  4e:   ff 75 f4                push   DWORD PTR [ebp-0xc]\n  51:   8d 45 08                lea    eax,[ebp+0x8]\n  54:   50                      push   eax\n  55:   e8 a6 ff ff ff          call   0 <second_func>\n  5a:   83 c4 10                add    esp,0x10\n  5d:   8b 45 08                mov    eax,DWORD PTR [ebp+0x8]\n  60:   8b 5d fc                mov    ebx,DWORD PTR [ebp-0x4]\n  63:   c9                      leave\n  64:   c3                      ret\n\n00000065 <main>:\n  65:   8d 4c 24 04             lea    ecx,[esp+0x4]\n  69:   83 e4 f0                and    esp,0xfffffff0\n  6c:   ff 71 fc                push   DWORD PTR [ecx-0x4]\n  6f:   55                      push   ebp\n  70:   89 e5                   mov    ebp,esp\n  72:   53                      push   ebx\n  73:   51                      push   ecx\n  74:   e8 fc ff ff ff          call   75 <main+0x10>\n  79:   81 c3 02 00 00 00       add    ebx,0x2\n  7f:   83 ec 0c                sub    esp,0xc\n  82:   6a 0f                   push   0xf\n  84:   e8 96 ff ff ff          call   1f <first_func>\n  89:   83 c4 10                add    esp,0x10\n  8c:   83 ec 08                sub    esp,0x8\n  8f:   50                      push   eax\n  90:   8d 83 0e 00 00 00       lea    eax,[ebx+0xe]\n  96:   50                      push   eax\n  97:   e8 fc ff ff ff          call   98 <main+0x33>\n  9c:   83 c4 10                add    esp,0x10\n  9f:   b8 00 00 00 00          mov    eax,0x0\n  a4:   8d 65 f8                lea    esp,[ebp-0x8]\n  a7:   59                      pop    ecx\n  a8:   5b                      pop    ebx\n  a9:   5d                      pop    ebp\n  aa:   8d 61 fc                lea    esp,[ecx-0x4]\n  ad:   c3                      ret\n")),(0,i.yg)("p",null,"There are many other utilities that allow disassembly of object modules, most of them with a graphical interface and offering debugging support.\n",(0,i.yg)("inlineCode",{parentName:"p"},"objdump")," is a simple utility that can be quickly used from the command-line."),(0,i.yg)("p",null,"It's interesting to observe, both in the ",(0,i.yg)("inlineCode",{parentName:"p"},"test.asm")," file and in its disassembly, the way a function call is made, which we'll discuss further."))}m.isMDXComponent=!0},2027:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/stack-7e53a701b7907c4331d4dfc24028236a.svg"}}]);